
ebpf_programs/object/default/prog47.bpf.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <lookup_map_of_maps_queue>:
; __u64 lookup_map_of_maps_queue (int key, __u64 counter/*, int iteration*/) {
       0:	63 1a f4 ff 00 00 00 00	*(u32 *)(r10 - 12) = r1
       1:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
;     struct inner_map_queue *map = bpf_map_lookup_elem(&outer_map_queue, &key);
       2:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       4:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
       5:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       7:	bf a2 00 00 00 00 00 00	r2 = r10
       8:	07 02 00 00 f4 ff ff ff	r2 += -12
       9:	8d 00 00 00 03 00 00 00	callx r3
      10:	7b 0a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r0
;     if(!map) {
      11:	79 a1 e0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 32)
      12:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_2>
      13:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

0000000000000070 <LBB0_1>:
      14:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      15:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
      16:	05 00 1c 00 00 00 00 00	goto +28 <LBB0_7>

0000000000000088 <LBB0_2>:
;     if(bpf_map_peek_elem(map, &value) < 0) {
      17:	18 01 00 00 08 00 00 00 00 00 00 00 00 00 00 00	r1 = 8 ll
      19:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      20:	79 a1 e0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 32)
      21:	bf a2 00 00 00 00 00 00	r2 = r10
      22:	07 02 00 00 d8 ff ff ff	r2 += -40
      23:	8d 00 00 00 03 00 00 00	callx r3
      24:	65 00 04 00 ff ff ff ff	if r0 s> -1 goto +4 <LBB0_4>
      25:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

00000000000000d0 <LBB0_3>:
      26:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      27:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
      28:	05 00 10 00 00 00 00 00	goto +16 <LBB0_7>

00000000000000e8 <LBB0_4>:
;     if(bpf_map_push_elem(map, &counter, BPF_EXIST) < 0) {
      29:	18 01 00 00 10 00 00 00 00 00 00 00 00 00 00 00	r1 = 16 ll
      31:	79 14 00 00 00 00 00 00	r4 = *(u64 *)(r1 + 0)
      32:	79 a1 e0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 32)
      33:	bf a2 00 00 00 00 00 00	r2 = r10
      34:	07 02 00 00 e8 ff ff ff	r2 += -24
      35:	b7 03 00 00 02 00 00 00	r3 = 2
      36:	8d 00 00 00 04 00 00 00	callx r4
      37:	65 00 04 00 ff ff ff ff	if r0 s> -1 goto +4 <LBB0_6>
      38:	05 00 00 00 00 00 00 00	goto +0 <LBB0_5>

0000000000000138 <LBB0_5>:
      39:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      40:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
      41:	05 00 03 00 00 00 00 00	goto +3 <LBB0_7>

0000000000000150 <LBB0_6>:
;     return counter;
      42:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
      43:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
      44:	05 00 00 00 00 00 00 00	goto +0 <LBB0_7>

0000000000000168 <LBB0_7>:
; }
      45:	79 a0 f8 ff 00 00 00 00	r0 = *(u64 *)(r10 - 8)
      46:	95 00 00 00 00 00 00 00	exit

0000000000000178 <get_counter>:
; __u64 get_counter (int key_cpu) {
      47:	63 1a f4 ff 00 00 00 00	*(u32 *)(r10 - 12) = r1
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      48:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      50:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      51:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      53:	bf a2 00 00 00 00 00 00	r2 = r10
      54:	07 02 00 00 f4 ff ff ff	r2 += -12
      55:	8d 00 00 00 03 00 00 00	callx r3
      56:	7b 0a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r0
;     if(!value)
      57:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
      58:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB1_2>
      59:	05 00 00 00 00 00 00 00	goto +0 <LBB1_1>

00000000000001e0 <LBB1_1>:
      60:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      61:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
      62:	05 00 04 00 00 00 00 00	goto +4 <LBB1_3>

00000000000001f8 <LBB1_2>:
;     return value->counter;
      63:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
      64:	79 11 08 00 00 00 00 00	r1 = *(u64 *)(r1 + 8)
      65:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
      66:	05 00 00 00 00 00 00 00	goto +0 <LBB1_3>

0000000000000218 <LBB1_3>:
; }
      67:	79 a0 f8 ff 00 00 00 00	r0 = *(u64 *)(r10 - 8)
      68:	95 00 00 00 00 00 00 00	exit

Disassembly of section xdp:

0000000000000000 <map_of_maps_queue>:
; {
       0:	7b 1a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r1
;     __u32 cpu = bpf_get_smp_processor_id();
       1:	18 01 00 00 18 00 00 00 00 00 00 00 00 00 00 00	r1 = 24 ll
       3:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
       4:	8d 00 00 00 01 00 00 00	callx r1
       5:	63 0a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r0
;     __u64 counter = get_counter(cpu);
       6:	61 a1 b4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 76)
       7:	85 10 00 00 ff ff ff ff	call -1
       8:	7b 0a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r0
;     __u64 arrival_time = bpf_ktime_get_ns();
       9:	18 01 00 00 20 00 00 00 00 00 00 00 00 00 00 00	r1 = 32 ll
      11:	7b 1a 90 ff 00 00 00 00	*(u64 *)(r10 - 112) = r1
      12:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      13:	8d 00 00 00 01 00 00 00	callx r1
      14:	7b 0a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r0
;     lookup_map_of_maps_queue(cpu, counter);
      15:	79 a2 a8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 88)
      16:	61 a1 b4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 76)
      17:	85 10 00 00 ff ff ff ff	call -1
      18:	79 a1 90 ff 00 00 00 00	r1 = *(u64 *)(r10 - 112)
;     __u64 finish_time = bpf_ktime_get_ns();
      19:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      20:	8d 00 00 00 01 00 00 00	callx r1
      21:	7b 0a 98 ff 00 00 00 00	*(u64 *)(r10 - 104) = r0
;     if(!update_info(arrival_time, finish_time, cpu)) {
      22:	79 a3 a0 ff 00 00 00 00	r3 = *(u64 *)(r10 - 96)
      23:	79 a2 98 ff 00 00 00 00	r2 = *(u64 *)(r10 - 104)
      24:	61 a1 b4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 76)
      25:	7b 3a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r3
      26:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
      27:	63 1a e4 ff 00 00 00 00	*(u32 *)(r10 - 28) = r1
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      28:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      30:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      31:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      33:	bf a2 00 00 00 00 00 00	r2 = r10
;     __u32 cpu = bpf_get_smp_processor_id();
      34:	07 02 00 00 e4 ff ff ff	r2 += -28
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      35:	8d 00 00 00 03 00 00 00	callx r3
      36:	7b 0a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r0
;     if(!value)
      37:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      38:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB2_2>
      39:	05 00 00 00 00 00 00 00	goto +0 <LBB2_1>

0000000000000140 <LBB2_1>:
      40:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      41:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      42:	05 00 19 00 00 00 00 00	goto +25 <LBB2_3>

0000000000000158 <LBB2_2>:
;     new_value.latency = value->latency + (finish_time - arrival_time);
      43:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      44:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      45:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      46:	79 a3 f0 ff 00 00 00 00	r3 = *(u64 *)(r10 - 16)
      47:	1f 32 00 00 00 00 00 00	r2 -= r3
      48:	0f 21 00 00 00 00 00 00	r1 += r2
      49:	7b 1a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r1
;     new_value.counter = value->counter + 1;
      50:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      51:	79 11 08 00 00 00 00 00	r1 = *(u64 *)(r1 + 8)
      52:	07 01 00 00 01 00 00 00	r1 += 1
      53:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      54:	18 01 00 00 28 00 00 00 00 00 00 00 00 00 00 00	r1 = 40 ll
      56:	79 15 00 00 00 00 00 00	r5 = *(u64 *)(r1 + 0)
      57:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      59:	bf a2 00 00 00 00 00 00	r2 = r10
;     new_value.latency = value->latency + (finish_time - arrival_time);
      60:	07 02 00 00 e4 ff ff ff	r2 += -28
      61:	bf a3 00 00 00 00 00 00	r3 = r10
      62:	07 03 00 00 c8 ff ff ff	r3 += -56
      63:	b7 04 00 00 00 00 00 00	r4 = 0
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      64:	8d 00 00 00 05 00 00 00	callx r5
      65:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      66:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      67:	05 00 00 00 00 00 00 00	goto +0 <LBB2_3>

0000000000000220 <LBB2_3>:
; }
      68:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
;     if(!update_info(arrival_time, finish_time, cpu)) {
      69:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB2_5>
      70:	05 00 00 00 00 00 00 00	goto +0 <LBB2_4>

0000000000000238 <LBB2_4>:
      71:	b7 01 00 00 01 00 00 00	r1 = 1
;         return XDP_DROP;
      72:	63 1a c4 ff 00 00 00 00	*(u32 *)(r10 - 60) = r1
      73:	05 00 03 00 00 00 00 00	goto +3 <LBB2_6>

0000000000000250 <LBB2_5>:
      74:	b7 01 00 00 01 00 00 00	r1 = 1
;     return XDP_DROP;
      75:	63 1a c4 ff 00 00 00 00	*(u32 *)(r10 - 60) = r1
      76:	05 00 00 00 00 00 00 00	goto +0 <LBB2_6>

0000000000000268 <LBB2_6>:
; }
      77:	61 a0 c4 ff 00 00 00 00	r0 = *(u32 *)(r10 - 60)
      78:	95 00 00 00 00 00 00 00	exit
