
ebpf_programs/object/default/prog34.bpf.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <helping_func>:
; __u32 helping_func(__u32 valiable) {
       0:	63 1a f8 ff 00 00 00 00	*(u32 *)(r10 - 8) = r1
;     if(valiable * 2 > 500)
       1:	61 a2 f8 ff 00 00 00 00	r2 = *(u32 *)(r10 - 8)
       2:	67 02 00 00 01 00 00 00	r2 <<= 1
       3:	67 02 00 00 20 00 00 00	r2 <<= 32
       4:	77 02 00 00 20 00 00 00	r2 >>= 32
       5:	b7 01 00 00 f5 01 00 00	r1 = 501
       6:	2d 21 04 00 00 00 00 00	if r1 > r2 goto +4 <LBB0_2>
       7:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

0000000000000040 <LBB0_1>:
;         return valiable;
       8:	61 a1 f8 ff 00 00 00 00	r1 = *(u32 *)(r10 - 8)
       9:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      10:	05 00 03 00 00 00 00 00	goto +3 <LBB0_3>

0000000000000058 <LBB0_2>:
      11:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      12:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      13:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

0000000000000070 <LBB0_3>:
; }
      14:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      15:	95 00 00 00 00 00 00 00	exit

0000000000000080 <second_func>:
; __u32 second_func(__u32 number) {
      16:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
;     return number * 10;
      17:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      18:	27 00 00 00 0a 00 00 00	r0 *= 10
      19:	95 00 00 00 00 00 00 00	exit

00000000000000a0 <updating_map>:
; void updating_map(__u32 *value, struct value *value2) {
      20:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
      21:	7b 2a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r2
;     *value = *value + 1;
      22:	79 a2 f8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 8)
      23:	61 21 00 00 00 00 00 00	r1 = *(u32 *)(r2 + 0)
      24:	07 01 00 00 01 00 00 00	r1 += 1
      25:	63 12 00 00 00 00 00 00	*(u32 *)(r2 + 0) = r1
;     value2->testing = *value;
      26:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
      27:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
      28:	79 a2 f0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 16)
      29:	63 12 00 00 00 00 00 00	*(u32 *)(r2 + 0) = r1
;     value2->testing2 = value2->testing * (*value);
      30:	79 a2 f0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 16)
      31:	61 21 00 00 00 00 00 00	r1 = *(u32 *)(r2 + 0)
      32:	79 a3 f8 ff 00 00 00 00	r3 = *(u64 *)(r10 - 8)
      33:	61 33 00 00 00 00 00 00	r3 = *(u32 *)(r3 + 0)
      34:	2f 31 00 00 00 00 00 00	r1 *= r3
      35:	63 12 04 00 00 00 00 00	*(u32 *)(r2 + 4) = r1
;     if(*value > 5) {
      36:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
      37:	61 12 00 00 00 00 00 00	r2 = *(u32 *)(r1 + 0)
      38:	b7 01 00 00 06 00 00 00	r1 = 6
      39:	2d 21 07 00 00 00 00 00	if r1 > r2 goto +7 <LBB2_2>
      40:	05 00 00 00 00 00 00 00	goto +0 <LBB2_1>

0000000000000148 <LBB2_1>:
;         *value = helping_func(*value);
      41:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
      42:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
      43:	85 10 00 00 ff ff ff ff	call -1
      44:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
      45:	63 01 00 00 00 00 00 00	*(u32 *)(r1 + 0) = r0
;     } else {
      46:	05 00 06 00 00 00 00 00	goto +6 <LBB2_3>

0000000000000178 <LBB2_2>:
;         value2->testing = second_func(*value);
      47:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
      48:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
      49:	85 10 00 00 ff ff ff ff	call -1
      50:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
      51:	63 01 00 00 00 00 00 00	*(u32 *)(r1 + 0) = r0
      52:	05 00 00 00 00 00 00 00	goto +0 <LBB2_3>

00000000000001a8 <LBB2_3>:
; }
      53:	95 00 00 00 00 00 00 00	exit

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; int xdp_prog(struct xdp_md *ctx) {
       0:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
;     __u32 data_start = ctx->data;
       1:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
       2:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
       3:	63 1a f4 ff 00 00 00 00	*(u32 *)(r10 - 12) = r1
;     __u32 data_end = ctx->data_end;
       4:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
       5:	61 11 04 00 00 00 00 00	r1 = *(u32 *)(r1 + 4)
       6:	63 1a f0 ff 00 00 00 00	*(u32 *)(r10 - 16) = r1
;     if(data_end > data_start) {
       7:	61 a2 f0 ff 00 00 00 00	r2 = *(u32 *)(r10 - 16)
       8:	61 a1 f4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 12)
       9:	3d 21 19 00 00 00 00 00	if r1 >= r2 goto +25 <LBB3_2>
      10:	05 00 00 00 00 00 00 00	goto +0 <LBB3_1>

0000000000000058 <LBB3_1>:
      11:	b7 01 00 00 00 00 00 00	r1 = 0
;         __u32 key = 0;
      12:	63 1a ec ff 00 00 00 00	*(u32 *)(r10 - 20) = r1
;         __u32* value = bpf_map_lookup_elem(&xdp_map, &key);
      13:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      15:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
      16:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      17:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      19:	bf a2 00 00 00 00 00 00	r2 = r10
;         __u32 key = 0;
      20:	07 02 00 00 ec ff ff ff	r2 += -20
;         __u32* value = bpf_map_lookup_elem(&xdp_map, &key);
      21:	7b 2a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r2
      22:	8d 00 00 00 03 00 00 00	callx r3
      23:	79 a2 c8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 56)
      24:	79 a1 d0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 48)
      25:	7b 0a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r0
;         struct value *value2 = bpf_map_lookup_elem(&map_value, &key);
      26:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      27:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      29:	8d 00 00 00 03 00 00 00	callx r3
      30:	7b 0a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r0
;         updating_map(value, value2);
      31:	79 a1 e0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 32)
      32:	79 a2 d8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 40)
      33:	85 10 00 00 ff ff ff ff	call -1
;     }
      34:	05 00 00 00 00 00 00 00	goto +0 <LBB3_2>

0000000000000118 <LBB3_2>:
      35:	b7 00 00 00 01 00 00 00	r0 = 1
;     return XDP_DROP; // Drop all packets
      36:	95 00 00 00 00 00 00 00	exit
