
ebpf_programs/object/default/prog48.bpf.o:	file format elf64-bpf

Disassembly of section xdp:

0000000000000000 <lock_map>:
; {
       0:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
;     int cpu = bpf_get_smp_processor_id();
       1:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       3:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
       4:	8d 00 00 00 01 00 00 00	callx r1
       5:	63 0a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r0
;     __u64 arrival_time = bpf_ktime_get_ns();
       6:	18 01 00 00 08 00 00 00 00 00 00 00 00 00 00 00	r1 = 8 ll
       8:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
       9:	8d 00 00 00 01 00 00 00	callx r1
      10:	7b 0a 98 ff 00 00 00 00	*(u64 *)(r10 - 104) = r0
      11:	b7 01 00 00 00 00 00 00	r1 = 0
      12:	63 1a c0 ff 00 00 00 00	*(u32 *)(r10 - 64) = r1
;     struct map_locked_value *lock_value = bpf_map_lookup_elem(&lock_array, &key);
      13:	18 01 00 00 10 00 00 00 00 00 00 00 00 00 00 00	r1 = 16 ll
      15:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      16:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      18:	bf a2 00 00 00 00 00 00	r2 = r10
;     int cpu = bpf_get_smp_processor_id();
      19:	07 02 00 00 c0 ff ff ff	r2 += -64
;     struct map_locked_value *lock_value = bpf_map_lookup_elem(&lock_array, &key);
      20:	8d 00 00 00 03 00 00 00	callx r3
      21:	7b 0a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r0
;     if(!lock_value) {
      22:	79 a1 b8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 72)
      23:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_2>
      24:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

00000000000000c8 <LBB0_1>:
      25:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      26:	63 1a c4 ff 00 00 00 00	*(u32 *)(r10 - 60) = r1
      27:	05 00 13 00 00 00 00 00	goto +19 <LBB0_3>

00000000000000e0 <LBB0_2>:
;     bpf_spin_lock(&lock_value->lock);
      28:	18 01 00 00 18 00 00 00 00 00 00 00 00 00 00 00	r1 = 24 ll
      30:	79 12 00 00 00 00 00 00	r2 = *(u64 *)(r1 + 0)
      31:	79 a1 b8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 72)
      32:	07 01 00 00 08 00 00 00	r1 += 8
      33:	8d 00 00 00 02 00 00 00	callx r2
;     lock_value->value += 1;
      34:	79 a2 b8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 72)
      35:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
      36:	07 01 00 00 01 00 00 00	r1 += 1
      37:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
;     bpf_spin_unlock(&lock_value->lock);
      38:	18 01 00 00 20 00 00 00 00 00 00 00 00 00 00 00	r1 = 32 ll
      40:	79 12 00 00 00 00 00 00	r2 = *(u64 *)(r1 + 0)
      41:	79 a1 b8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 72)
      42:	07 01 00 00 08 00 00 00	r1 += 8
      43:	8d 00 00 00 02 00 00 00	callx r2
      44:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      45:	63 1a c4 ff 00 00 00 00	*(u32 *)(r10 - 60) = r1
      46:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

0000000000000178 <LBB0_3>:
;     __u64 finish_time = bpf_ktime_get_ns();
      47:	18 01 00 00 08 00 00 00 00 00 00 00 00 00 00 00	r1 = 8 ll
      49:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      50:	8d 00 00 00 01 00 00 00	callx r1
      51:	7b 0a 90 ff 00 00 00 00	*(u64 *)(r10 - 112) = r0
;     if(!update_info(arrival_time, finish_time, cpu)) {
      52:	79 a3 98 ff 00 00 00 00	r3 = *(u64 *)(r10 - 104)
      53:	79 a2 90 ff 00 00 00 00	r2 = *(u64 *)(r10 - 112)
      54:	61 a1 a4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 92)
      55:	7b 3a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r3
      56:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
      57:	63 1a e4 ff 00 00 00 00	*(u32 *)(r10 - 28) = r1
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      58:	18 01 00 00 10 00 00 00 00 00 00 00 00 00 00 00	r1 = 16 ll
      60:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      61:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      63:	bf a2 00 00 00 00 00 00	r2 = r10
;     __u64 finish_time = bpf_ktime_get_ns();
      64:	07 02 00 00 e4 ff ff ff	r2 += -28
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      65:	8d 00 00 00 03 00 00 00	callx r3
      66:	7b 0a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r0
;     if(!value)
      67:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      68:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_5>
      69:	05 00 00 00 00 00 00 00	goto +0 <LBB0_4>

0000000000000230 <LBB0_4>:
      70:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      71:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      72:	05 00 19 00 00 00 00 00	goto +25 <LBB0_6>

0000000000000248 <LBB0_5>:
;     new_value.latency = value->latency + (finish_time - arrival_time);
      73:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      74:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      75:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      76:	79 a3 f0 ff 00 00 00 00	r3 = *(u64 *)(r10 - 16)
      77:	1f 32 00 00 00 00 00 00	r2 -= r3
      78:	0f 21 00 00 00 00 00 00	r1 += r2
      79:	7b 1a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r1
;     new_value.counter = value->counter + 1;
      80:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      81:	79 11 08 00 00 00 00 00	r1 = *(u64 *)(r1 + 8)
      82:	07 01 00 00 01 00 00 00	r1 += 1
      83:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      84:	18 01 00 00 28 00 00 00 00 00 00 00 00 00 00 00	r1 = 40 ll
      86:	79 15 00 00 00 00 00 00	r5 = *(u64 *)(r1 + 0)
      87:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      89:	bf a2 00 00 00 00 00 00	r2 = r10
;     new_value.latency = value->latency + (finish_time - arrival_time);
      90:	07 02 00 00 e4 ff ff ff	r2 += -28
      91:	bf a3 00 00 00 00 00 00	r3 = r10
      92:	07 03 00 00 c8 ff ff ff	r3 += -56
      93:	b7 04 00 00 00 00 00 00	r4 = 0
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      94:	8d 00 00 00 05 00 00 00	callx r5
      95:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      96:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      97:	05 00 00 00 00 00 00 00	goto +0 <LBB0_6>

0000000000000310 <LBB0_6>:
; }
      98:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
;     if(!update_info(arrival_time, finish_time, cpu)) {
      99:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_8>
     100:	05 00 00 00 00 00 00 00	goto +0 <LBB0_7>

0000000000000328 <LBB0_7>:
     101:	b7 01 00 00 01 00 00 00	r1 = 1
;         return XDP_DROP;
     102:	63 1a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r1
     103:	05 00 03 00 00 00 00 00	goto +3 <LBB0_9>

0000000000000340 <LBB0_8>:
     104:	b7 01 00 00 01 00 00 00	r1 = 1
;     return XDP_DROP;
     105:	63 1a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r1
     106:	05 00 00 00 00 00 00 00	goto +0 <LBB0_9>

0000000000000358 <LBB0_9>:
; }
     107:	61 a0 b4 ff 00 00 00 00	r0 = *(u32 *)(r10 - 76)
     108:	95 00 00 00 00 00 00 00	exit
