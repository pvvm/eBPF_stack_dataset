
ebpf_programs/object/default/prog41.bpf.o:	file format elf64-bpf

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; int xdp_prog(struct xdp_md *ctx) {
       0:	7b 1a 78 ff 00 00 00 00	*(u64 *)(r10 - 136) = r1
;     void *data_end = (void *)(long)ctx->data_end;
       1:	79 a1 78 ff 00 00 00 00	r1 = *(u64 *)(r10 - 136)
       2:	61 11 04 00 00 00 00 00	r1 = *(u32 *)(r1 + 4)
       3:	7b 1a 70 ff 00 00 00 00	*(u64 *)(r10 - 144) = r1
; 	void *data = (void *)(long)ctx->data;
       4:	79 a1 78 ff 00 00 00 00	r1 = *(u64 *)(r10 - 136)
       5:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
       6:	7b 1a 68 ff 00 00 00 00	*(u64 *)(r10 - 152) = r1
; 	nh.pos = data;
       7:	79 a1 68 ff 00 00 00 00	r1 = *(u64 *)(r10 - 152)
       8:	7b 1a 58 ff 00 00 00 00	*(u64 *)(r10 - 168) = r1
; 	nh_type = parse_ethhdr(&nh, data_end, &eth);
       9:	79 a1 70 ff 00 00 00 00	r1 = *(u64 *)(r10 - 144)
      10:	bf a2 00 00 00 00 00 00	r2 = r10
;     void *data_end = (void *)(long)ctx->data_end;
      11:	07 02 00 00 58 ff ff ff	r2 += -168
      12:	7b 2a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r2
      13:	7b 1a 98 ff 00 00 00 00	*(u64 *)(r10 - 104) = r1
      14:	bf a1 00 00 00 00 00 00	r1 = r10
      15:	07 01 00 00 60 ff ff ff	r1 += -160
      16:	7b 1a 90 ff 00 00 00 00	*(u64 *)(r10 - 112) = r1
; struct ethhdr *eth = nh->pos;
      17:	79 a1 a0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 96)
      18:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      19:	7b 1a 88 ff 00 00 00 00	*(u64 *)(r10 - 120) = r1
      20:	b7 01 00 00 0e 00 00 00	r1 = 14
; int hdrsize = sizeof(*eth);
      21:	63 1a 84 ff 00 00 00 00	*(u32 *)(r10 - 124) = r1
; if (nh->pos + 1 > data_end)
      22:	79 a1 a0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 96)
      23:	79 12 00 00 00 00 00 00	r2 = *(u64 *)(r1 + 0)
      24:	07 02 00 00 01 00 00 00	r2 += 1
      25:	79 a1 98 ff 00 00 00 00	r1 = *(u64 *)(r10 - 104)
      26:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB0_2>
      27:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

00000000000000e0 <LBB0_1>:
      28:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      30:	63 1a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r1
      31:	05 00 11 00 00 00 00 00	goto +17 <LBB0_3>

0000000000000100 <LBB0_2>:
; nh->pos += hdrsize;
      32:	61 a3 84 ff 00 00 00 00	r3 = *(u32 *)(r10 - 124)
      33:	67 03 00 00 20 00 00 00	r3 <<= 32
      34:	c7 03 00 00 20 00 00 00	r3 s>>= 32
      35:	79 a2 a0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 96)
      36:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
      37:	0f 31 00 00 00 00 00 00	r1 += r3
      38:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; *ethhdr = eth;
      39:	79 a1 88 ff 00 00 00 00	r1 = *(u64 *)(r10 - 120)
      40:	79 a2 90 ff 00 00 00 00	r2 = *(u64 *)(r10 - 112)
      41:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; return eth->h_proto;
      42:	79 a1 88 ff 00 00 00 00	r1 = *(u64 *)(r10 - 120)
      43:	71 12 0c 00 00 00 00 00	r2 = *(u8 *)(r1 + 12)
      44:	71 11 0d 00 00 00 00 00	r1 = *(u8 *)(r1 + 13)
      45:	67 01 00 00 08 00 00 00	r1 <<= 8
      46:	4f 21 00 00 00 00 00 00	r1 |= r2
      47:	63 1a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r1
      48:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

0000000000000188 <LBB0_3>:
; }
      49:	61 a1 a8 ff 00 00 00 00	r1 = *(u32 *)(r10 - 88)
; 	nh_type = parse_ethhdr(&nh, data_end, &eth);
      50:	63 1a 54 ff 00 00 00 00	*(u32 *)(r10 - 172) = r1
; 	if (nh_type != bpf_htons(ETH_P_IPV6))
      51:	61 a1 54 ff 00 00 00 00	r1 = *(u32 *)(r10 - 172)
      52:	15 01 04 00 86 dd 00 00	if r1 == 56710 goto +4 <LBB0_5>
      53:	05 00 00 00 00 00 00 00	goto +0 <LBB0_4>

00000000000001b0 <LBB0_4>:
      54:	b7 01 00 00 01 00 00 00	r1 = 1
;         return XDP_DROP;
      55:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
      56:	05 00 6f 00 00 00 00 00	goto +111 <LBB0_20>

00000000000001c8 <LBB0_5>:
; 		nh_type = parse_iphdr(&nh, data_end, &iph);
      57:	79 a1 70 ff 00 00 00 00	r1 = *(u64 *)(r10 - 144)
      58:	bf a2 00 00 00 00 00 00	r2 = r10
      59:	07 02 00 00 58 ff ff ff	r2 += -168
      60:	7b 2a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r2
      61:	7b 1a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r1
      62:	bf a1 00 00 00 00 00 00	r1 = r10
      63:	07 01 00 00 48 ff ff ff	r1 += -184
      64:	7b 1a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r1
; struct iphdr *iph = nh->pos;
      65:	79 a1 c8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 56)
      66:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      67:	7b 1a b0 ff 00 00 00 00	*(u64 *)(r10 - 80) = r1
; if (iph + 1 > data_end)
      68:	79 a2 b0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 80)
      69:	07 02 00 00 14 00 00 00	r2 += 20
      70:	79 a1 c0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 64)
      71:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB0_7>
      72:	05 00 00 00 00 00 00 00	goto +0 <LBB0_6>

0000000000000248 <LBB0_6>:
      73:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      75:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
      76:	05 00 29 00 00 00 00 00	goto +41 <LBB0_12>

0000000000000268 <LBB0_7>:
; hdrsize = iph->ihl * 4;
      77:	79 a1 b0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 80)
      78:	71 11 00 00 00 00 00 00	r1 = *(u8 *)(r1 + 0)
      79:	57 01 00 00 0f 00 00 00	r1 &= 15
      80:	67 01 00 00 02 00 00 00	r1 <<= 2
      81:	63 1a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r1
; if(hdrsize < sizeof(*iph))
      82:	61 a1 ac ff 00 00 00 00	r1 = *(u32 *)(r10 - 84)
      83:	67 01 00 00 20 00 00 00	r1 <<= 32
      84:	c7 01 00 00 20 00 00 00	r1 s>>= 32
      85:	25 01 05 00 13 00 00 00	if r1 > 19 goto +5 <LBB0_9>
      86:	05 00 00 00 00 00 00 00	goto +0 <LBB0_8>

00000000000002b8 <LBB0_8>:
      87:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      89:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
      90:	05 00 1b 00 00 00 00 00	goto +27 <LBB0_12>

00000000000002d8 <LBB0_9>:
; if (nh->pos + hdrsize > data_end)
      91:	79 a1 c8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 56)
      92:	79 12 00 00 00 00 00 00	r2 = *(u64 *)(r1 + 0)
      93:	61 a1 ac ff 00 00 00 00	r1 = *(u32 *)(r10 - 84)
      94:	67 01 00 00 20 00 00 00	r1 <<= 32
      95:	c7 01 00 00 20 00 00 00	r1 s>>= 32
      96:	0f 12 00 00 00 00 00 00	r2 += r1
      97:	79 a1 c0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 64)
      98:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB0_11>
      99:	05 00 00 00 00 00 00 00	goto +0 <LBB0_10>

0000000000000320 <LBB0_10>:
     100:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
     102:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
     103:	05 00 0e 00 00 00 00 00	goto +14 <LBB0_12>

0000000000000340 <LBB0_11>:
; nh->pos += hdrsize;
     104:	61 a3 ac ff 00 00 00 00	r3 = *(u32 *)(r10 - 84)
     105:	67 03 00 00 20 00 00 00	r3 <<= 32
     106:	c7 03 00 00 20 00 00 00	r3 s>>= 32
     107:	79 a2 c8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 56)
     108:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
     109:	0f 31 00 00 00 00 00 00	r1 += r3
     110:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; *iphdr = iph;
     111:	79 a1 b0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 80)
     112:	79 a2 b8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 72)
     113:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; return iph->protocol;
     114:	79 a1 b0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 80)
     115:	71 11 09 00 00 00 00 00	r1 = *(u8 *)(r1 + 9)
     116:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
     117:	05 00 00 00 00 00 00 00	goto +0 <LBB0_12>

00000000000003b0 <LBB0_12>:
; }
     118:	61 a1 d4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 44)
; 		nh_type = parse_iphdr(&nh, data_end, &iph);
     119:	63 1a 54 ff 00 00 00 00	*(u32 *)(r10 - 172) = r1
; 		if (nh_type != 0)
     120:	61 a1 54 ff 00 00 00 00	r1 = *(u32 *)(r10 - 172)
     121:	15 01 04 00 00 00 00 00	if r1 == 0 goto +4 <LBB0_14>
     122:	05 00 00 00 00 00 00 00	goto +0 <LBB0_13>

00000000000003d8 <LBB0_13>:
     123:	b7 01 00 00 01 00 00 00	r1 = 1
; 			return XDP_DROP;
     124:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
     125:	05 00 2a 00 00 00 00 00	goto +42 <LBB0_20>

00000000000003f0 <LBB0_14>:
; 		nh_type = parse_icmphdr(&nh, data_end, &icmph);
     126:	79 a1 70 ff 00 00 00 00	r1 = *(u64 *)(r10 - 144)
     127:	bf a2 00 00 00 00 00 00	r2 = r10
     128:	07 02 00 00 58 ff ff ff	r2 += -168
     129:	7b 2a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r2
     130:	7b 1a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r1
     131:	bf a1 00 00 00 00 00 00	r1 = r10
     132:	07 01 00 00 40 ff ff ff	r1 += -192
     133:	7b 1a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r1
; struct icmphdr *icmph = nh->pos;
     134:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
     135:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
     136:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
; if (icmph + 1 > data_end)
     137:	79 a2 d8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 40)
     138:	07 02 00 00 08 00 00 00	r2 += 8
     139:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
     140:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB0_16>
     141:	05 00 00 00 00 00 00 00	goto +0 <LBB0_15>

0000000000000470 <LBB0_15>:
     142:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
     144:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
     145:	05 00 0b 00 00 00 00 00	goto +11 <LBB0_17>

0000000000000490 <LBB0_16>:
; nh->pos  = icmph + 1;
     146:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
     147:	07 01 00 00 08 00 00 00	r1 += 8
     148:	79 a2 f0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 16)
     149:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; *icmphdr = icmph;
     150:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
     151:	79 a2 e0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 32)
     152:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; return icmph->type;
     153:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
     154:	71 11 00 00 00 00 00 00	r1 = *(u8 *)(r1 + 0)
     155:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
     156:	05 00 00 00 00 00 00 00	goto +0 <LBB0_17>

00000000000004e8 <LBB0_17>:
; }
     157:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
; 		nh_type = parse_icmphdr(&nh, data_end, &icmph);
     158:	63 1a 54 ff 00 00 00 00	*(u32 *)(r10 - 172) = r1
; 		if (nh_type != ICMP_ECHO)
     159:	61 a1 54 ff 00 00 00 00	r1 = *(u32 *)(r10 - 172)
     160:	15 01 04 00 08 00 00 00	if r1 == 8 goto +4 <LBB0_19>
     161:	05 00 00 00 00 00 00 00	goto +0 <LBB0_18>

0000000000000510 <LBB0_18>:
     162:	b7 01 00 00 01 00 00 00	r1 = 1
; 			return XDP_DROP;
     163:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
     164:	05 00 03 00 00 00 00 00	goto +3 <LBB0_20>

0000000000000528 <LBB0_19>:
     165:	b7 01 00 00 01 00 00 00	r1 = 1
;     return XDP_DROP;
     166:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
     167:	05 00 00 00 00 00 00 00	goto +0 <LBB0_20>

0000000000000540 <LBB0_20>:
; }
     168:	61 a0 80 ff 00 00 00 00	r0 = *(u32 *)(r10 - 128)
     169:	95 00 00 00 00 00 00 00	exit
