
ebpf_programs/object/default/prog39.bpf.o:	file format elf64-bpf

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; int xdp_prog(struct xdp_md *ctx) {
       0:	7b 1a 78 ff 00 00 00 00	*(u64 *)(r10 - 136) = r1
;     void *data_end = (void *)(long)ctx->data_end;
       1:	79 a1 78 ff 00 00 00 00	r1 = *(u64 *)(r10 - 136)
       2:	61 11 04 00 00 00 00 00	r1 = *(u32 *)(r1 + 4)
       3:	7b 1a 70 ff 00 00 00 00	*(u64 *)(r10 - 144) = r1
; 	void *data = (void *)(long)ctx->data;
       4:	79 a1 78 ff 00 00 00 00	r1 = *(u64 *)(r10 - 136)
       5:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
       6:	7b 1a 68 ff 00 00 00 00	*(u64 *)(r10 - 152) = r1
; 	nh.pos = data;
       7:	79 a1 68 ff 00 00 00 00	r1 = *(u64 *)(r10 - 152)
       8:	7b 1a 58 ff 00 00 00 00	*(u64 *)(r10 - 168) = r1
; 	nh_type = parse_ethhdr(&nh, data_end, &eth);
       9:	79 a1 70 ff 00 00 00 00	r1 = *(u64 *)(r10 - 144)
      10:	bf a2 00 00 00 00 00 00	r2 = r10
;     void *data_end = (void *)(long)ctx->data_end;
      11:	07 02 00 00 58 ff ff ff	r2 += -168
      12:	7b 2a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r2
      13:	7b 1a 98 ff 00 00 00 00	*(u64 *)(r10 - 104) = r1
      14:	bf a1 00 00 00 00 00 00	r1 = r10
      15:	07 01 00 00 60 ff ff ff	r1 += -160
      16:	7b 1a 90 ff 00 00 00 00	*(u64 *)(r10 - 112) = r1
; struct ethhdr *eth = nh->pos;
      17:	79 a1 a0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 96)
      18:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      19:	7b 1a 88 ff 00 00 00 00	*(u64 *)(r10 - 120) = r1
      20:	b7 01 00 00 0e 00 00 00	r1 = 14
; int hdrsize = sizeof(*eth);
      21:	63 1a 84 ff 00 00 00 00	*(u32 *)(r10 - 124) = r1
; if (nh->pos + 1 > data_end)
      22:	79 a1 a0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 96)
      23:	79 12 00 00 00 00 00 00	r2 = *(u64 *)(r1 + 0)
      24:	07 02 00 00 01 00 00 00	r2 += 1
      25:	79 a1 98 ff 00 00 00 00	r1 = *(u64 *)(r10 - 104)
      26:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB0_2>
      27:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

00000000000000e0 <LBB0_1>:
      28:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      30:	63 1a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r1
      31:	05 00 11 00 00 00 00 00	goto +17 <LBB0_3>

0000000000000100 <LBB0_2>:
; nh->pos += hdrsize;
      32:	61 a3 84 ff 00 00 00 00	r3 = *(u32 *)(r10 - 124)
      33:	67 03 00 00 20 00 00 00	r3 <<= 32
      34:	c7 03 00 00 20 00 00 00	r3 s>>= 32
      35:	79 a2 a0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 96)
      36:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
      37:	0f 31 00 00 00 00 00 00	r1 += r3
      38:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; *ethhdr = eth;
      39:	79 a1 88 ff 00 00 00 00	r1 = *(u64 *)(r10 - 120)
      40:	79 a2 90 ff 00 00 00 00	r2 = *(u64 *)(r10 - 112)
      41:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; return eth->h_proto;
      42:	79 a1 88 ff 00 00 00 00	r1 = *(u64 *)(r10 - 120)
      43:	71 12 0c 00 00 00 00 00	r2 = *(u8 *)(r1 + 12)
      44:	71 11 0d 00 00 00 00 00	r1 = *(u8 *)(r1 + 13)
      45:	67 01 00 00 08 00 00 00	r1 <<= 8
      46:	4f 21 00 00 00 00 00 00	r1 |= r2
      47:	63 1a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r1
      48:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

0000000000000188 <LBB0_3>:
; }
      49:	61 a1 ac ff 00 00 00 00	r1 = *(u32 *)(r10 - 84)
; 	nh_type = parse_ethhdr(&nh, data_end, &eth);
      50:	63 1a 54 ff 00 00 00 00	*(u32 *)(r10 - 172) = r1
; 	if (nh_type != bpf_htons(ETH_P_IPV6))
      51:	61 a1 54 ff 00 00 00 00	r1 = *(u32 *)(r10 - 172)
      52:	15 01 04 00 86 dd 00 00	if r1 == 56710 goto +4 <LBB0_5>
      53:	05 00 00 00 00 00 00 00	goto +0 <LBB0_4>

00000000000001b0 <LBB0_4>:
      54:	b7 01 00 00 01 00 00 00	r1 = 1
;         return XDP_DROP;
      55:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
      56:	05 00 5f 00 00 00 00 00	goto +95 <LBB0_20>

00000000000001c8 <LBB0_5>:
; 	nh_type = parse_ip6hdr(&nh, data_end, &ip6h);
      57:	79 a1 70 ff 00 00 00 00	r1 = *(u64 *)(r10 - 144)
      58:	bf a2 00 00 00 00 00 00	r2 = r10
      59:	07 02 00 00 58 ff ff ff	r2 += -168
      60:	7b 2a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r2
      61:	7b 1a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r1
      62:	bf a1 00 00 00 00 00 00	r1 = r10
      63:	07 01 00 00 48 ff ff ff	r1 += -184
      64:	7b 1a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r1
; struct ipv6hdr *ip6h = nh->pos;
      65:	79 a1 c8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 56)
      66:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      67:	7b 1a b0 ff 00 00 00 00	*(u64 *)(r10 - 80) = r1
; if (ip6h + 1 > data_end)
      68:	79 a2 b0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 80)
      69:	07 02 00 00 28 00 00 00	r2 += 40
      70:	79 a1 c0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 64)
      71:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB0_7>
      72:	05 00 00 00 00 00 00 00	goto +0 <LBB0_6>

0000000000000248 <LBB0_6>:
      73:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      75:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
      76:	05 00 0b 00 00 00 00 00	goto +11 <LBB0_8>

0000000000000268 <LBB0_7>:
; nh->pos = ip6h + 1;
      77:	79 a1 b0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 80)
      78:	07 01 00 00 28 00 00 00	r1 += 40
      79:	79 a2 c8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 56)
      80:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; *ip6hdr = ip6h;
      81:	79 a1 b0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 80)
      82:	79 a2 b8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 72)
      83:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; return ip6h->nexthdr;
      84:	79 a1 b0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 80)
      85:	71 11 06 00 00 00 00 00	r1 = *(u8 *)(r1 + 6)
      86:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
      87:	05 00 00 00 00 00 00 00	goto +0 <LBB0_8>

00000000000002c0 <LBB0_8>:
; }
      88:	61 a1 d4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 44)
; 	nh_type = parse_ip6hdr(&nh, data_end, &ip6h);
      89:	63 1a 54 ff 00 00 00 00	*(u32 *)(r10 - 172) = r1
; 	if (nh_type != IPPROTO_ICMPV6)
      90:	61 a1 54 ff 00 00 00 00	r1 = *(u32 *)(r10 - 172)
      91:	15 01 04 00 3a 00 00 00	if r1 == 58 goto +4 <LBB0_10>
      92:	05 00 00 00 00 00 00 00	goto +0 <LBB0_9>

00000000000002e8 <LBB0_9>:
      93:	b7 01 00 00 01 00 00 00	r1 = 1
; 		return XDP_DROP;
      94:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
      95:	05 00 38 00 00 00 00 00	goto +56 <LBB0_20>

0000000000000300 <LBB0_10>:
; 	nh_type = parse_icmp6hdr(&nh, data_end, &icmp6h);
      96:	79 a1 70 ff 00 00 00 00	r1 = *(u64 *)(r10 - 144)
      97:	bf a2 00 00 00 00 00 00	r2 = r10
      98:	07 02 00 00 58 ff ff ff	r2 += -168
      99:	7b 2a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r2
     100:	7b 1a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r1
     101:	bf a1 00 00 00 00 00 00	r1 = r10
     102:	07 01 00 00 40 ff ff ff	r1 += -192
     103:	7b 1a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r1
; struct icmp6hdr *icmp6h = nh->pos;
     104:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
     105:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
     106:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
; if (icmp6h + 1 > data_end)
     107:	79 a2 d8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 40)
     108:	07 02 00 00 08 00 00 00	r2 += 8
     109:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
     110:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB0_12>
     111:	05 00 00 00 00 00 00 00	goto +0 <LBB0_11>

0000000000000380 <LBB0_11>:
     112:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
     114:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
     115:	05 00 0b 00 00 00 00 00	goto +11 <LBB0_13>

00000000000003a0 <LBB0_12>:
; nh->pos   = icmp6h + 1;
     116:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
     117:	07 01 00 00 08 00 00 00	r1 += 8
     118:	79 a2 f0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 16)
     119:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; *icmp6hdr = icmp6h;
     120:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
     121:	79 a2 e0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 32)
     122:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; return icmp6h->icmp6_type;
     123:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
     124:	71 11 00 00 00 00 00 00	r1 = *(u8 *)(r1 + 0)
     125:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
     126:	05 00 00 00 00 00 00 00	goto +0 <LBB0_13>

00000000000003f8 <LBB0_13>:
; }
     127:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
; 	nh_type = parse_icmp6hdr(&nh, data_end, &icmp6h);
     128:	63 1a 54 ff 00 00 00 00	*(u32 *)(r10 - 172) = r1
; 	if (nh_type != ICMPV6_ECHO_REQUEST)
     129:	61 a1 54 ff 00 00 00 00	r1 = *(u32 *)(r10 - 172)
     130:	15 01 04 00 80 00 00 00	if r1 == 128 goto +4 <LBB0_15>
     131:	05 00 00 00 00 00 00 00	goto +0 <LBB0_14>

0000000000000420 <LBB0_14>:
     132:	b7 01 00 00 01 00 00 00	r1 = 1
; 		return XDP_DROP;
     133:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
     134:	05 00 11 00 00 00 00 00	goto +17 <LBB0_20>

0000000000000438 <LBB0_15>:
     135:	05 00 00 00 00 00 00 00	goto +0 <LBB0_16>

0000000000000440 <LBB0_16>:
; 	if (bpf_ntohs(icmp6h->icmp6_sequence) == 0)
     136:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     137:	69 11 06 00 00 00 00 00	r1 = *(u16 *)(r1 + 6)
     138:	dc 01 00 00 10 00 00 00	r1 = be16 r1
     139:	7b 1a 38 ff 00 00 00 00	*(u64 *)(r10 - 200) = r1
     140:	05 00 00 00 00 00 00 00	goto +0 <LBB0_17>

0000000000000468 <LBB0_17>:
     141:	79 a1 38 ff 00 00 00 00	r1 = *(u64 *)(r10 - 200)
     142:	67 01 00 00 20 00 00 00	r1 <<= 32
     143:	77 01 00 00 20 00 00 00	r1 >>= 32
     144:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_19>
     145:	05 00 00 00 00 00 00 00	goto +0 <LBB0_18>

0000000000000490 <LBB0_18>:
     146:	b7 01 00 00 01 00 00 00	r1 = 1
; 		return XDP_DROP;
     147:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
     148:	05 00 03 00 00 00 00 00	goto +3 <LBB0_20>

00000000000004a8 <LBB0_19>:
     149:	b7 01 00 00 01 00 00 00	r1 = 1
;     return XDP_DROP; // Drop all packets
     150:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
     151:	05 00 00 00 00 00 00 00	goto +0 <LBB0_20>

00000000000004c0 <LBB0_20>:
; }
     152:	61 a0 80 ff 00 00 00 00	r0 = *(u32 *)(r10 - 128)
     153:	95 00 00 00 00 00 00 00	exit
