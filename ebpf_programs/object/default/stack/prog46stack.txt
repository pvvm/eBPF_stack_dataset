
ebpf_programs/object/default/prog46.bpf.o:	file format elf64-bpf

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; {
       0:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
;     __u32 cpu = bpf_get_smp_processor_id();
       1:	18 01 00 00 08 00 00 00 00 00 00 00 00 00 00 00	r1 = 8 ll
       3:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
       4:	8d 00 00 00 01 00 00 00	callx r1
       5:	63 0a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r0
;     if(cpu >= 10)
       6:	61 a2 fc ff 00 00 00 00	r2 = *(u32 *)(r10 - 4)
       7:	b7 01 00 00 0a 00 00 00	r1 = 10
       8:	2d 21 05 00 00 00 00 00	if r1 > r2 goto +5 <LBB0_2>
       9:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

0000000000000050 <LBB0_1>:
;         cpu -= 10;
      10:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
      11:	07 01 00 00 f6 ff ff ff	r1 += -10
      12:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      13:	05 00 00 00 00 00 00 00	goto +0 <LBB0_2>

0000000000000070 <LBB0_2>:
;     return cpu;
      14:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
;     __u32 cpu = get_and_check_cpu_id();
      15:	63 1a 9c ff 00 00 00 00	*(u32 *)(r10 - 100) = r1
;     __u64 arrival_time = bpf_ktime_get_ns();
      16:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      18:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      19:	8d 00 00 00 01 00 00 00	callx r1
      20:	7b 0a 90 ff 00 00 00 00	*(u64 *)(r10 - 112) = r0
;     lookup_map(cpu, &common_array);
      21:	61 a1 9c ff 00 00 00 00	r1 = *(u32 *)(r10 - 100)
      22:	63 1a c0 ff 00 00 00 00	*(u32 *)(r10 - 64) = r1
      23:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      25:	7b 1a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r1
;     __u64 * value = bpf_map_lookup_elem(map_pointer, &key);
      26:	18 01 00 00 10 00 00 00 00 00 00 00 00 00 00 00	r1 = 16 ll
      28:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      29:	79 a1 b8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 72)
      30:	bf a2 00 00 00 00 00 00	r2 = r10
;     return cpu;
      31:	07 02 00 00 c0 ff ff ff	r2 += -64
;     __u64 * value = bpf_map_lookup_elem(map_pointer, &key);
      32:	8d 00 00 00 03 00 00 00	callx r3
      33:	7b 0a b0 ff 00 00 00 00	*(u64 *)(r10 - 80) = r0
;     if(!value)
      34:	79 a1 b0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 80)
      35:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_4>
      36:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

0000000000000128 <LBB0_3>:
      37:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      38:	63 1a c4 ff 00 00 00 00	*(u32 *)(r10 - 60) = r1
      39:	05 00 07 00 00 00 00 00	goto +7 <LBB0_5>

0000000000000140 <LBB0_4>:
;     *value += 1;
      40:	79 a2 b0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 80)
      41:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
      42:	07 01 00 00 01 00 00 00	r1 += 1
      43:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
      44:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      45:	63 1a c4 ff 00 00 00 00	*(u32 *)(r10 - 60) = r1
      46:	05 00 00 00 00 00 00 00	goto +0 <LBB0_5>

0000000000000178 <LBB0_5>:
;     __u64 finish_time = bpf_ktime_get_ns();
      47:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      49:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      50:	8d 00 00 00 01 00 00 00	callx r1
      51:	7b 0a 88 ff 00 00 00 00	*(u64 *)(r10 - 120) = r0
;     if(!update_info(arrival_time, finish_time, cpu)) {
      52:	79 a3 90 ff 00 00 00 00	r3 = *(u64 *)(r10 - 112)
      53:	79 a2 88 ff 00 00 00 00	r2 = *(u64 *)(r10 - 120)
      54:	61 a1 9c ff 00 00 00 00	r1 = *(u32 *)(r10 - 100)
      55:	7b 3a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r3
      56:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
      57:	63 1a e4 ff 00 00 00 00	*(u32 *)(r10 - 28) = r1
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      58:	18 01 00 00 10 00 00 00 00 00 00 00 00 00 00 00	r1 = 16 ll
      60:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      61:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      63:	bf a2 00 00 00 00 00 00	r2 = r10
;     __u64 finish_time = bpf_ktime_get_ns();
      64:	07 02 00 00 e4 ff ff ff	r2 += -28
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      65:	8d 00 00 00 03 00 00 00	callx r3
      66:	7b 0a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r0
;     if(!value)
      67:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      68:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_7>
      69:	05 00 00 00 00 00 00 00	goto +0 <LBB0_6>

0000000000000230 <LBB0_6>:
      70:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      71:	63 1a f8 ff 00 00 00 00	*(u32 *)(r10 - 8) = r1
      72:	05 00 19 00 00 00 00 00	goto +25 <LBB0_8>

0000000000000248 <LBB0_7>:
;     new_value.latency = value->latency + (finish_time - arrival_time);
      73:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      74:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      75:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      76:	79 a3 f0 ff 00 00 00 00	r3 = *(u64 *)(r10 - 16)
      77:	1f 32 00 00 00 00 00 00	r2 -= r3
      78:	0f 21 00 00 00 00 00 00	r1 += r2
      79:	7b 1a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r1
;     new_value.counter = value->counter + 1;
      80:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      81:	79 11 08 00 00 00 00 00	r1 = *(u64 *)(r1 + 8)
      82:	07 01 00 00 01 00 00 00	r1 += 1
      83:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      84:	18 01 00 00 18 00 00 00 00 00 00 00 00 00 00 00	r1 = 24 ll
      86:	79 15 00 00 00 00 00 00	r5 = *(u64 *)(r1 + 0)
      87:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      89:	bf a2 00 00 00 00 00 00	r2 = r10
;     new_value.latency = value->latency + (finish_time - arrival_time);
      90:	07 02 00 00 e4 ff ff ff	r2 += -28
      91:	bf a3 00 00 00 00 00 00	r3 = r10
      92:	07 03 00 00 c8 ff ff ff	r3 += -56
      93:	b7 04 00 00 00 00 00 00	r4 = 0
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      94:	8d 00 00 00 05 00 00 00	callx r5
      95:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      96:	63 1a f8 ff 00 00 00 00	*(u32 *)(r10 - 8) = r1
      97:	05 00 00 00 00 00 00 00	goto +0 <LBB0_8>

0000000000000310 <LBB0_8>:
; }
      98:	61 a1 f8 ff 00 00 00 00	r1 = *(u32 *)(r10 - 8)
;     if(!update_info(arrival_time, finish_time, cpu)) {
      99:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_10>
     100:	05 00 00 00 00 00 00 00	goto +0 <LBB0_9>

0000000000000328 <LBB0_9>:
     101:	b7 01 00 00 01 00 00 00	r1 = 1
;         return XDP_DROP;
     102:	63 1a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r1
     103:	05 00 03 00 00 00 00 00	goto +3 <LBB0_11>

0000000000000340 <LBB0_10>:
     104:	b7 01 00 00 01 00 00 00	r1 = 1
;     return XDP_DROP;
     105:	63 1a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r1
     106:	05 00 00 00 00 00 00 00	goto +0 <LBB0_11>

0000000000000358 <LBB0_11>:
; }
     107:	61 a0 ac ff 00 00 00 00	r0 = *(u32 *)(r10 - 84)
     108:	95 00 00 00 00 00 00 00	exit
