
ebpf_programs/object/default/prog46.bpf.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <update_info>:
; int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) {
       0:	7b 1a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r1
       1:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
       2:	63 3a e4 ff 00 00 00 00	*(u32 *)(r10 - 28) = r3
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
       3:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       5:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
       6:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       8:	bf a2 00 00 00 00 00 00	r2 = r10
       9:	07 02 00 00 e4 ff ff ff	r2 += -28
      10:	8d 00 00 00 03 00 00 00	callx r3
      11:	7b 0a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r0
;     if(!value)
      12:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      13:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_2>
      14:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

0000000000000078 <LBB0_1>:
      15:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      16:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      17:	05 00 19 00 00 00 00 00	goto +25 <LBB0_3>

0000000000000090 <LBB0_2>:
;     new_value.latency = value->latency + (finish_time - arrival_time);
      18:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      19:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      20:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      21:	79 a3 f0 ff 00 00 00 00	r3 = *(u64 *)(r10 - 16)
      22:	1f 32 00 00 00 00 00 00	r2 -= r3
      23:	0f 21 00 00 00 00 00 00	r1 += r2
      24:	7b 1a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r1
;     new_value.counter = value->counter + 1;
      25:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      26:	79 11 08 00 00 00 00 00	r1 = *(u64 *)(r1 + 8)
      27:	07 01 00 00 01 00 00 00	r1 += 1
      28:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      29:	18 01 00 00 08 00 00 00 00 00 00 00 00 00 00 00	r1 = 8 ll
      31:	79 15 00 00 00 00 00 00	r5 = *(u64 *)(r1 + 0)
      32:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      34:	bf a2 00 00 00 00 00 00	r2 = r10
;     new_value.latency = value->latency + (finish_time - arrival_time);
      35:	07 02 00 00 e4 ff ff ff	r2 += -28
      36:	bf a3 00 00 00 00 00 00	r3 = r10
      37:	07 03 00 00 c8 ff ff ff	r3 += -56
      38:	b7 04 00 00 00 00 00 00	r4 = 0
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      39:	8d 00 00 00 05 00 00 00	callx r5
      40:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      41:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      42:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

0000000000000158 <LBB0_3>:
; }
      43:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      44:	95 00 00 00 00 00 00 00	exit

0000000000000168 <lookup_map>:
; int lookup_map (int key, void * map_pointer) {
      45:	63 1a f8 ff 00 00 00 00	*(u32 *)(r10 - 8) = r1
      46:	7b 2a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r2
;     __u64 * value = bpf_map_lookup_elem(map_pointer, &key);
      47:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      49:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      50:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
      51:	bf a2 00 00 00 00 00 00	r2 = r10
      52:	07 02 00 00 f8 ff ff ff	r2 += -8
      53:	8d 00 00 00 03 00 00 00	callx r3
      54:	7b 0a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r0
;     if(!value)
      55:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
      56:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB1_2>
      57:	05 00 00 00 00 00 00 00	goto +0 <LBB1_1>

00000000000001d0 <LBB1_1>:
      58:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      59:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      60:	05 00 07 00 00 00 00 00	goto +7 <LBB1_3>

00000000000001e8 <LBB1_2>:
;     *value += 1;
      61:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      62:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
      63:	07 01 00 00 01 00 00 00	r1 += 1
      64:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
      65:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      66:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      67:	05 00 00 00 00 00 00 00	goto +0 <LBB1_3>

0000000000000220 <LBB1_3>:
; }
      68:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      69:	95 00 00 00 00 00 00 00	exit

0000000000000230 <get_and_check_cpu_id>:
;     __u32 cpu = bpf_get_smp_processor_id();
      70:	18 01 00 00 10 00 00 00 00 00 00 00 00 00 00 00	r1 = 16 ll
      72:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      73:	8d 00 00 00 01 00 00 00	callx r1
      74:	63 0a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r0
;     if(cpu >= 10)
      75:	61 a2 fc ff 00 00 00 00	r2 = *(u32 *)(r10 - 4)
      76:	b7 01 00 00 0a 00 00 00	r1 = 10
      77:	2d 21 05 00 00 00 00 00	if r1 > r2 goto +5 <LBB2_2>
      78:	05 00 00 00 00 00 00 00	goto +0 <LBB2_1>

0000000000000278 <LBB2_1>:
;         cpu -= 10;
      79:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
      80:	07 01 00 00 f6 ff ff ff	r1 += -10
      81:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      82:	05 00 00 00 00 00 00 00	goto +0 <LBB2_2>

0000000000000298 <LBB2_2>:
;     return cpu;
      83:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      84:	95 00 00 00 00 00 00 00	exit

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; {
       0:	7b 1a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r1
;     __u32 cpu = get_and_check_cpu_id();
       1:	85 10 00 00 ff ff ff ff	call -1
       2:	63 0a ec ff 00 00 00 00	*(u32 *)(r10 - 20) = r0
;     __u64 arrival_time = bpf_ktime_get_ns();
       3:	18 01 00 00 18 00 00 00 00 00 00 00 00 00 00 00	r1 = 24 ll
       5:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
       6:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
       7:	8d 00 00 00 01 00 00 00	callx r1
       8:	7b 0a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r0
;     lookup_map(cpu, &common_array);
       9:	61 a1 ec ff 00 00 00 00	r1 = *(u32 *)(r10 - 20)
      10:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
      12:	85 10 00 00 ff ff ff ff	call -1
      13:	79 a1 d0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 48)
;     __u64 finish_time = bpf_ktime_get_ns();
      14:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      15:	8d 00 00 00 01 00 00 00	callx r1
      16:	7b 0a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r0
;     if(!update_info(arrival_time, finish_time, cpu)) {
      17:	79 a1 e0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 32)
      18:	79 a2 d8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 40)
      19:	61 a3 ec ff 00 00 00 00	r3 = *(u32 *)(r10 - 20)
      20:	85 10 00 00 ff ff ff ff	call -1
      21:	bf 01 00 00 00 00 00 00	r1 = r0
      22:	67 01 00 00 20 00 00 00	r1 <<= 32
      23:	77 01 00 00 20 00 00 00	r1 >>= 32
      24:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB3_2>
      25:	05 00 00 00 00 00 00 00	goto +0 <LBB3_1>

00000000000000d0 <LBB3_1>:
      26:	b7 01 00 00 01 00 00 00	r1 = 1
;         return XDP_DROP;
      27:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      28:	05 00 03 00 00 00 00 00	goto +3 <LBB3_3>

00000000000000e8 <LBB3_2>:
      29:	b7 01 00 00 01 00 00 00	r1 = 1
;     return XDP_DROP;
      30:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      31:	05 00 00 00 00 00 00 00	goto +0 <LBB3_3>

0000000000000100 <LBB3_3>:
; }
      32:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      33:	95 00 00 00 00 00 00 00	exit
