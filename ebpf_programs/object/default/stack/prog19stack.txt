
ebpf_programs/object/default/prog19.bpf.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <testing_func>:
; void testing_func(__u32 *value) {
       0:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
;     if(*value > 123) {
       1:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
       2:	61 12 00 00 00 00 00 00	r2 = *(u32 *)(r1 + 0)
       3:	b7 01 00 00 7c 00 00 00	r1 = 124
       4:	2d 21 05 00 00 00 00 00	if r1 > r2 goto +5 <LBB0_2>
       5:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

0000000000000030 <LBB0_1>:
;         *value = 10;
       6:	79 a2 f8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 8)
       7:	b7 01 00 00 0a 00 00 00	r1 = 10
       8:	63 12 00 00 00 00 00 00	*(u32 *)(r2 + 0) = r1
;     }
       9:	05 00 00 00 00 00 00 00	goto +0 <LBB0_2>

0000000000000050 <LBB0_2>:
;     return;
      10:	95 00 00 00 00 00 00 00	exit

0000000000000058 <helper>:
; __u16 helper() {
      11:	b7 01 00 00 0c 00 00 00	r1 = 12
;     __u8 g = 12;
      12:	73 1a fd ff 00 00 00 00	*(u8 *)(r10 - 3) = r1
;     __u16 uga = g * 2;
      13:	71 a1 fd ff 00 00 00 00	r1 = *(u8 *)(r10 - 3)
      14:	67 01 00 00 01 00 00 00	r1 <<= 1
      15:	6b 1a fa ff 00 00 00 00	*(u16 *)(r10 - 6) = r1
      16:	b7 01 00 00 f4 01 00 00	r1 = 500
;     value = 500;
      17:	63 1a f4 ff 00 00 00 00	*(u32 *)(r10 - 12) = r1
      18:	bf a1 00 00 00 00 00 00	r1 = r10
;     __u8 g = 12;
      19:	07 01 00 00 f4 ff ff ff	r1 += -12
;     testing_func(&value);
      20:	85 10 00 00 ff ff ff ff	call -1
;     if(value > uga) {
      21:	61 a2 f4 ff 00 00 00 00	r2 = *(u32 *)(r10 - 12)
      22:	69 a1 fa ff 00 00 00 00	r1 = *(u16 *)(r10 - 6)
      23:	3d 21 04 00 00 00 00 00	if r1 >= r2 goto +4 <LBB1_2>
      24:	05 00 00 00 00 00 00 00	goto +0 <LBB1_1>

00000000000000c8 <LBB1_1>:
;         return uga;
      25:	69 a1 fa ff 00 00 00 00	r1 = *(u16 *)(r10 - 6)
      26:	6b 1a fe ff 00 00 00 00	*(u16 *)(r10 - 2) = r1
      27:	05 00 03 00 00 00 00 00	goto +3 <LBB1_3>

00000000000000e0 <LBB1_2>:
;     return value;
      28:	61 a1 f4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 12)
      29:	6b 1a fe ff 00 00 00 00	*(u16 *)(r10 - 2) = r1
      30:	05 00 00 00 00 00 00 00	goto +0 <LBB1_3>

00000000000000f8 <LBB1_3>:
; }
      31:	69 a0 fe ff 00 00 00 00	r0 = *(u16 *)(r10 - 2)
      32:	95 00 00 00 00 00 00 00	exit

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; int xdp_prog(struct xdp_md *ctx) {
       0:	7b 1a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r1
       1:	b7 01 00 00 01 00 00 00	r1 = 1
;     __u32 this = 1;
       2:	63 1a ec ff 00 00 00 00	*(u32 *)(r10 - 20) = r1
       3:	b7 01 00 00 00 00 00 00	r1 = 0
;     __u8 value = 0;
       4:	73 1a eb ff 00 00 00 00	*(u8 *)(r10 - 21) = r1
       5:	b7 01 00 00 06 00 00 00	r1 = 6
;     __u8 you_are_cool = 1 + 5;
       6:	73 1a ea ff 00 00 00 00	*(u8 *)(r10 - 22) = r1
;     this = this + -1;
       7:	61 a1 ec ff 00 00 00 00	r1 = *(u32 *)(r10 - 20)
       8:	07 01 00 00 ff ff ff ff	r1 += -1
       9:	63 1a ec ff 00 00 00 00	*(u32 *)(r10 - 20) = r1
;     __u32 data_start = ctx->data;
      10:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
      11:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
      12:	63 1a e4 ff 00 00 00 00	*(u32 *)(r10 - 28) = r1
;     __u32 data_end = ctx->data_end;
      13:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
      14:	61 11 04 00 00 00 00 00	r1 = *(u32 *)(r1 + 4)
      15:	63 1a e0 ff 00 00 00 00	*(u32 *)(r10 - 32) = r1
;     if(data_end < data_start)
      16:	61 a1 e0 ff 00 00 00 00	r1 = *(u32 *)(r10 - 32)
      17:	61 a2 e4 ff 00 00 00 00	r2 = *(u32 *)(r10 - 28)
      18:	3d 21 04 00 00 00 00 00	if r1 >= r2 goto +4 <LBB2_2>
      19:	05 00 00 00 00 00 00 00	goto +0 <LBB2_1>

00000000000000a0 <LBB2_1>:
      20:	b7 01 00 00 01 00 00 00	r1 = 1
;         return XDP_DROP;
      21:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      22:	05 00 1a 00 00 00 00 00	goto +26 <LBB2_7>

00000000000000b8 <LBB2_2>:
;     struct xdp_md *copy = ctx;
      23:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
      24:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
;     __u32 rx_index = copy->rx_queue_index;
      25:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      26:	61 11 10 00 00 00 00 00	r1 = *(u32 *)(r1 + 16)
      27:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
;     if(you_are_cool > value) {
      28:	71 a2 ea ff 00 00 00 00	r2 = *(u8 *)(r10 - 22)
      29:	71 a1 eb ff 00 00 00 00	r1 = *(u8 *)(r10 - 21)
      30:	7d 21 09 00 00 00 00 00	if r1 s>= r2 goto +9 <LBB2_4>
      31:	05 00 00 00 00 00 00 00	goto +0 <LBB2_3>

0000000000000100 <LBB2_3>:
;         __u16 helper_return = helper();
      32:	85 10 00 00 ff ff ff ff	call -1
      33:	6b 0a d2 ff 00 00 00 00	*(u16 *)(r10 - 46) = r0
;         helper_return = helper_return + 1;;
      34:	69 a1 d2 ff 00 00 00 00	r1 = *(u16 *)(r10 - 46)
      35:	07 01 00 00 01 00 00 00	r1 += 1
      36:	6b 1a d2 ff 00 00 00 00	*(u16 *)(r10 - 46) = r1
      37:	b7 01 00 00 02 00 00 00	r1 = 2
;         return XDP_PASS;
      38:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      39:	05 00 09 00 00 00 00 00	goto +9 <LBB2_7>

0000000000000140 <LBB2_4>:
;     if(rx_index != 0)
      40:	61 a1 d4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 44)
      41:	15 01 04 00 00 00 00 00	if r1 == 0 goto +4 <LBB2_6>
      42:	05 00 00 00 00 00 00 00	goto +0 <LBB2_5>

0000000000000158 <LBB2_5>:
      43:	b7 01 00 00 00 00 00 00	r1 = 0
;         this = 0;
      44:	63 1a ec ff 00 00 00 00	*(u32 *)(r10 - 20) = r1
      45:	05 00 00 00 00 00 00 00	goto +0 <LBB2_6>

0000000000000170 <LBB2_6>:
      46:	b7 01 00 00 01 00 00 00	r1 = 1
;     return XDP_DROP; // Drop all packets
      47:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      48:	05 00 00 00 00 00 00 00	goto +0 <LBB2_7>

0000000000000188 <LBB2_7>:
; }
      49:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      50:	95 00 00 00 00 00 00 00	exit
