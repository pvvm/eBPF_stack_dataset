
ebpf_programs/object/default/prog45.bpf.o:	file format elf64-bpf

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; {
       0:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
;     __u32 cpu = bpf_get_smp_processor_id();
       1:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       3:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
       4:	8d 00 00 00 01 00 00 00	callx r1
       5:	63 0a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r0
;     __u64 arrival_time = bpf_ktime_get_ns();
       6:	18 01 00 00 08 00 00 00 00 00 00 00 00 00 00 00	r1 = 8 ll
       8:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
       9:	8d 00 00 00 01 00 00 00	callx r1
      10:	7b 0a 98 ff 00 00 00 00	*(u64 *)(r10 - 104) = r0
;     lookup_map(cpu, &common_array);
      11:	61 a1 a4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 92)
      12:	63 1a c0 ff 00 00 00 00	*(u32 *)(r10 - 64) = r1
      13:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      15:	7b 1a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r1
;     __u64 * value = bpf_map_lookup_elem(map_pointer, &key);
      16:	18 01 00 00 18 00 00 00 00 00 00 00 00 00 00 00	r1 = 24 ll
      18:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      19:	79 a1 b8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 72)
      20:	bf a2 00 00 00 00 00 00	r2 = r10
;     __u32 cpu = bpf_get_smp_processor_id();
      21:	07 02 00 00 c0 ff ff ff	r2 += -64
;     __u64 * value = bpf_map_lookup_elem(map_pointer, &key);
      22:	8d 00 00 00 03 00 00 00	callx r3
      23:	7b 0a b0 ff 00 00 00 00	*(u64 *)(r10 - 80) = r0
;     if(!value)
      24:	79 a1 b0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 80)
      25:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_2>
      26:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

00000000000000d8 <LBB0_1>:
      27:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      28:	63 1a c4 ff 00 00 00 00	*(u32 *)(r10 - 60) = r1
      29:	05 00 07 00 00 00 00 00	goto +7 <LBB0_3>

00000000000000f0 <LBB0_2>:
;     *value += 1;
      30:	79 a2 b0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 80)
      31:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
      32:	07 01 00 00 01 00 00 00	r1 += 1
      33:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
      34:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      35:	63 1a c4 ff 00 00 00 00	*(u32 *)(r10 - 60) = r1
      36:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

0000000000000128 <LBB0_3>:
;     __u64 finish_time = bpf_ktime_get_ns();
      37:	18 01 00 00 08 00 00 00 00 00 00 00 00 00 00 00	r1 = 8 ll
      39:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      40:	8d 00 00 00 01 00 00 00	callx r1
      41:	7b 0a 90 ff 00 00 00 00	*(u64 *)(r10 - 112) = r0
;     if(!update_info(arrival_time, finish_time, cpu)) {
      42:	79 a3 98 ff 00 00 00 00	r3 = *(u64 *)(r10 - 104)
      43:	79 a2 90 ff 00 00 00 00	r2 = *(u64 *)(r10 - 112)
      44:	61 a1 a4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 92)
      45:	7b 3a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r3
      46:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
      47:	63 1a e4 ff 00 00 00 00	*(u32 *)(r10 - 28) = r1
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      48:	18 01 00 00 18 00 00 00 00 00 00 00 00 00 00 00	r1 = 24 ll
      50:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      51:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      53:	bf a2 00 00 00 00 00 00	r2 = r10
;     __u64 finish_time = bpf_ktime_get_ns();
      54:	07 02 00 00 e4 ff ff ff	r2 += -28
;     struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu);
      55:	8d 00 00 00 03 00 00 00	callx r3
      56:	7b 0a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r0
;     if(!value)
      57:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      58:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB0_5>
      59:	05 00 00 00 00 00 00 00	goto +0 <LBB0_4>

00000000000001e0 <LBB0_4>:
      60:	b7 01 00 00 00 00 00 00	r1 = 0
;         return 0;
      61:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      62:	05 00 19 00 00 00 00 00	goto +25 <LBB0_6>

00000000000001f8 <LBB0_5>:
;     new_value.latency = value->latency + (finish_time - arrival_time);
      63:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      64:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      65:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      66:	79 a3 f0 ff 00 00 00 00	r3 = *(u64 *)(r10 - 16)
      67:	1f 32 00 00 00 00 00 00	r2 -= r3
      68:	0f 21 00 00 00 00 00 00	r1 += r2
      69:	7b 1a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r1
;     new_value.counter = value->counter + 1;
      70:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      71:	79 11 08 00 00 00 00 00	r1 = *(u64 *)(r1 + 8)
      72:	07 01 00 00 01 00 00 00	r1 += 1
      73:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      74:	18 01 00 00 20 00 00 00 00 00 00 00 00 00 00 00	r1 = 32 ll
      76:	79 15 00 00 00 00 00 00	r5 = *(u64 *)(r1 + 0)
      77:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      79:	bf a2 00 00 00 00 00 00	r2 = r10
;     new_value.latency = value->latency + (finish_time - arrival_time);
      80:	07 02 00 00 e4 ff ff ff	r2 += -28
      81:	bf a3 00 00 00 00 00 00	r3 = r10
      82:	07 03 00 00 c8 ff ff ff	r3 += -56
      83:	b7 04 00 00 00 00 00 00	r4 = 0
;     bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);
      84:	8d 00 00 00 05 00 00 00	callx r5
      85:	b7 01 00 00 01 00 00 00	r1 = 1
;     return 1;
      86:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      87:	05 00 00 00 00 00 00 00	goto +0 <LBB0_6>

00000000000002c0 <LBB0_6>:
; }
      88:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
;     if(!update_info(arrival_time, finish_time, cpu)) {
      89:	55 01 18 00 00 00 00 00	if r1 != 0 goto +24 <LBB0_8>
      90:	05 00 00 00 00 00 00 00	goto +0 <LBB0_7>

00000000000002d8 <LBB0_7>:
      91:	b7 01 00 00 00 00 00 00	r1 = 0
;         bpf_printk("Error while looking up timer map");
      92:	73 1a 88 ff 00 00 00 00	*(u8 *)(r10 - 120) = r1
      93:	18 01 00 00 69 6d 65 72 00 00 00 00 20 6d 61 70	r1 = 8097873591114493289 ll
      95:	7b 1a 80 ff 00 00 00 00	*(u64 *)(r10 - 128) = r1
      96:	18 01 00 00 69 6e 67 20 00 00 00 00 75 70 20 74	r1 = 8367811756011515497 ll
      98:	7b 1a 78 ff 00 00 00 00	*(u64 *)(r10 - 136) = r1
      99:	18 01 00 00 69 6c 65 20 00 00 00 00 6c 6f 6f 6b	r1 = 7741528794663840873 ll
     101:	7b 1a 70 ff 00 00 00 00	*(u64 *)(r10 - 144) = r1
     102:	18 01 00 00 45 72 72 6f 00 00 00 00 72 20 77 68	r1 = 7527520978041205317 ll
     104:	7b 1a 68 ff 00 00 00 00	*(u64 *)(r10 - 152) = r1
     105:	18 01 00 00 10 00 00 00 00 00 00 00 00 00 00 00	r1 = 16 ll
     107:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
     108:	bf a1 00 00 00 00 00 00	r1 = r10
     109:	07 01 00 00 68 ff ff ff	r1 += -152
     110:	b7 02 00 00 21 00 00 00	r2 = 33
     111:	8d 00 00 00 03 00 00 00	callx r3
     112:	7b 0a 60 ff 00 00 00 00	*(u64 *)(r10 - 160) = r0
;     }
     113:	05 00 00 00 00 00 00 00	goto +0 <LBB0_8>

0000000000000390 <LBB0_8>:
     114:	b7 00 00 00 01 00 00 00	r0 = 1
;     return XDP_DROP;
     115:	95 00 00 00 00 00 00 00	exit
