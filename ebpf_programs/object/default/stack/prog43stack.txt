
ebpf_programs/object/default/prog43.bpf.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <parse_ethhdr>:
; {
       0:	7b 1a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r1
       1:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
       2:	7b 3a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r3
; struct ethhdr *eth = nh->pos;
       3:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
       4:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
       5:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
       6:	b7 01 00 00 0e 00 00 00	r1 = 14
; int hdrsize = sizeof(*eth);
       7:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
; if (nh->pos + 1 > data_end)
       8:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
       9:	79 12 00 00 00 00 00 00	r2 = *(u64 *)(r1 + 0)
      10:	07 02 00 00 01 00 00 00	r2 += 1
      11:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
      12:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB0_2>
      13:	05 00 00 00 00 00 00 00	goto +0 <LBB0_1>

0000000000000070 <LBB0_1>:
      14:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      16:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      17:	05 00 11 00 00 00 00 00	goto +17 <LBB0_3>

0000000000000090 <LBB0_2>:
; nh->pos += hdrsize;
      18:	61 a3 d4 ff 00 00 00 00	r3 = *(u32 *)(r10 - 44)
      19:	67 03 00 00 20 00 00 00	r3 <<= 32
      20:	c7 03 00 00 20 00 00 00	r3 s>>= 32
      21:	79 a2 f0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 16)
      22:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
      23:	0f 31 00 00 00 00 00 00	r1 += r3
      24:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; *ethhdr = eth;
      25:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      26:	79 a2 e0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 32)
      27:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; return eth->h_proto;
      28:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      29:	71 12 0c 00 00 00 00 00	r2 = *(u8 *)(r1 + 12)
      30:	71 11 0d 00 00 00 00 00	r1 = *(u8 *)(r1 + 13)
      31:	67 01 00 00 08 00 00 00	r1 <<= 8
      32:	4f 21 00 00 00 00 00 00	r1 |= r2
      33:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      34:	05 00 00 00 00 00 00 00	goto +0 <LBB0_3>

0000000000000118 <LBB0_3>:
; }
      35:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      36:	95 00 00 00 00 00 00 00	exit

0000000000000128 <parse_iphdr>:
; {
      37:	7b 1a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r1
      38:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
      39:	7b 3a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r3
; struct iphdr *iph = nh->pos;
      40:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
      41:	79 11 00 00 00 00 00 00	r1 = *(u64 *)(r1 + 0)
      42:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
; if (iph + 1 > data_end)
      43:	79 a2 d8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 40)
      44:	07 02 00 00 14 00 00 00	r2 += 20
      45:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
      46:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB1_2>
      47:	05 00 00 00 00 00 00 00	goto +0 <LBB1_1>

0000000000000180 <LBB1_1>:
      48:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      50:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      51:	05 00 29 00 00 00 00 00	goto +41 <LBB1_7>

00000000000001a0 <LBB1_2>:
; hdrsize = iph->ihl * 4;
      52:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      53:	71 11 00 00 00 00 00 00	r1 = *(u8 *)(r1 + 0)
      54:	57 01 00 00 0f 00 00 00	r1 &= 15
      55:	67 01 00 00 02 00 00 00	r1 <<= 2
      56:	63 1a d4 ff 00 00 00 00	*(u32 *)(r10 - 44) = r1
; if(hdrsize < sizeof(*iph))
      57:	61 a1 d4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 44)
      58:	67 01 00 00 20 00 00 00	r1 <<= 32
      59:	c7 01 00 00 20 00 00 00	r1 s>>= 32
      60:	25 01 05 00 13 00 00 00	if r1 > 19 goto +5 <LBB1_4>
      61:	05 00 00 00 00 00 00 00	goto +0 <LBB1_3>

00000000000001f0 <LBB1_3>:
      62:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      64:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      65:	05 00 1b 00 00 00 00 00	goto +27 <LBB1_7>

0000000000000210 <LBB1_4>:
; if (nh->pos + hdrsize > data_end)
      66:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
      67:	79 12 00 00 00 00 00 00	r2 = *(u64 *)(r1 + 0)
      68:	61 a1 d4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 44)
      69:	67 01 00 00 20 00 00 00	r1 <<= 32
      70:	c7 01 00 00 20 00 00 00	r1 s>>= 32
      71:	0f 12 00 00 00 00 00 00	r2 += r1
      72:	79 a1 e8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 24)
      73:	3d 21 05 00 00 00 00 00	if r1 >= r2 goto +5 <LBB1_6>
      74:	05 00 00 00 00 00 00 00	goto +0 <LBB1_5>

0000000000000258 <LBB1_5>:
      75:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
; return -1;
      77:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      78:	05 00 0e 00 00 00 00 00	goto +14 <LBB1_7>

0000000000000278 <LBB1_6>:
; nh->pos += hdrsize;
      79:	61 a3 d4 ff 00 00 00 00	r3 = *(u32 *)(r10 - 44)
      80:	67 03 00 00 20 00 00 00	r3 <<= 32
      81:	c7 03 00 00 20 00 00 00	r3 s>>= 32
      82:	79 a2 f0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 16)
      83:	79 21 00 00 00 00 00 00	r1 = *(u64 *)(r2 + 0)
      84:	0f 31 00 00 00 00 00 00	r1 += r3
      85:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; *iphdr = iph;
      86:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      87:	79 a2 e0 ff 00 00 00 00	r2 = *(u64 *)(r10 - 32)
      88:	7b 12 00 00 00 00 00 00	*(u64 *)(r2 + 0) = r1
; return iph->protocol;
      89:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      90:	71 11 09 00 00 00 00 00	r1 = *(u8 *)(r1 + 9)
      91:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      92:	05 00 00 00 00 00 00 00	goto +0 <LBB1_7>

00000000000002e8 <LBB1_7>:
; }
      93:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      94:	95 00 00 00 00 00 00 00	exit

00000000000002f8 <swap_src_dst_mac>:
; {
      95:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
; 	__builtin_memcpy(h_tmp, eth->h_source, ETH_ALEN);
      96:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
      97:	71 13 0a 00 00 00 00 00	r3 = *(u8 *)(r1 + 10)
      98:	71 12 0b 00 00 00 00 00	r2 = *(u8 *)(r1 + 11)
      99:	67 02 00 00 08 00 00 00	r2 <<= 8
     100:	4f 32 00 00 00 00 00 00	r2 |= r3
     101:	6b 2a f4 ff 00 00 00 00	*(u16 *)(r10 - 12) = r2
     102:	71 13 06 00 00 00 00 00	r3 = *(u8 *)(r1 + 6)
     103:	71 12 07 00 00 00 00 00	r2 = *(u8 *)(r1 + 7)
     104:	67 02 00 00 08 00 00 00	r2 <<= 8
     105:	4f 32 00 00 00 00 00 00	r2 |= r3
     106:	71 13 08 00 00 00 00 00	r3 = *(u8 *)(r1 + 8)
     107:	71 11 09 00 00 00 00 00	r1 = *(u8 *)(r1 + 9)
     108:	67 01 00 00 08 00 00 00	r1 <<= 8
     109:	4f 31 00 00 00 00 00 00	r1 |= r3
     110:	67 01 00 00 10 00 00 00	r1 <<= 16
     111:	4f 21 00 00 00 00 00 00	r1 |= r2
     112:	63 1a f0 ff 00 00 00 00	*(u32 *)(r10 - 16) = r1
; 	__builtin_memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     113:	79 a2 f8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 8)
     114:	71 21 03 00 00 00 00 00	r1 = *(u8 *)(r2 + 3)
     115:	73 12 09 00 00 00 00 00	*(u8 *)(r2 + 9) = r1
     116:	71 21 02 00 00 00 00 00	r1 = *(u8 *)(r2 + 2)
     117:	73 12 08 00 00 00 00 00	*(u8 *)(r2 + 8) = r1
     118:	71 21 01 00 00 00 00 00	r1 = *(u8 *)(r2 + 1)
     119:	73 12 07 00 00 00 00 00	*(u8 *)(r2 + 7) = r1
     120:	71 21 00 00 00 00 00 00	r1 = *(u8 *)(r2 + 0)
     121:	73 12 06 00 00 00 00 00	*(u8 *)(r2 + 6) = r1
     122:	71 21 05 00 00 00 00 00	r1 = *(u8 *)(r2 + 5)
     123:	73 12 0b 00 00 00 00 00	*(u8 *)(r2 + 11) = r1
     124:	71 21 04 00 00 00 00 00	r1 = *(u8 *)(r2 + 4)
     125:	73 12 0a 00 00 00 00 00	*(u8 *)(r2 + 10) = r1
; 	__builtin_memcpy(eth->h_dest, h_tmp, ETH_ALEN);
     126:	79 a2 f8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 8)
     127:	61 a1 f0 ff 00 00 00 00	r1 = *(u32 *)(r10 - 16)
     128:	bf 13 00 00 00 00 00 00	r3 = r1
     129:	77 03 00 00 18 00 00 00	r3 >>= 24
     130:	73 32 03 00 00 00 00 00	*(u8 *)(r2 + 3) = r3
     131:	bf 13 00 00 00 00 00 00	r3 = r1
     132:	77 03 00 00 10 00 00 00	r3 >>= 16
     133:	73 32 02 00 00 00 00 00	*(u8 *)(r2 + 2) = r3
     134:	73 12 00 00 00 00 00 00	*(u8 *)(r2 + 0) = r1
     135:	77 01 00 00 08 00 00 00	r1 >>= 8
     136:	73 12 01 00 00 00 00 00	*(u8 *)(r2 + 1) = r1
     137:	69 a1 f4 ff 00 00 00 00	r1 = *(u16 *)(r10 - 12)
     138:	73 12 04 00 00 00 00 00	*(u8 *)(r2 + 4) = r1
     139:	77 01 00 00 08 00 00 00	r1 >>= 8
     140:	73 12 05 00 00 00 00 00	*(u8 *)(r2 + 5) = r1
; }
     141:	95 00 00 00 00 00 00 00	exit

0000000000000470 <swap_src_dst_ipv4>:
; {
     142:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
; 	__be32 tmp = iphdr->saddr;
     143:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
     144:	61 11 0c 00 00 00 00 00	r1 = *(u32 *)(r1 + 12)
     145:	63 1a f4 ff 00 00 00 00	*(u32 *)(r10 - 12) = r1
; 	iphdr->saddr = iphdr->daddr;
     146:	79 a2 f8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 8)
     147:	61 21 10 00 00 00 00 00	r1 = *(u32 *)(r2 + 16)
     148:	63 12 0c 00 00 00 00 00	*(u32 *)(r2 + 12) = r1
; 	iphdr->daddr = tmp;
     149:	61 a1 f4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 12)
     150:	79 a2 f8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 8)
     151:	63 12 10 00 00 00 00 00	*(u32 *)(r2 + 16) = r1
; }
     152:	95 00 00 00 00 00 00 00	exit

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; int xdp_prog(struct xdp_md *ctx) {
       0:	7b 1a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r1
;     void *data_end = (void *)(long)ctx->data_end;
       1:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
       2:	61 11 04 00 00 00 00 00	r1 = *(u32 *)(r1 + 4)
       3:	7b 1a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r1
; 	void *data = (void *)(long)ctx->data;
       4:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
       5:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
       6:	7b 1a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r1
; 	nh.pos = data;
       7:	79 a1 e0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 32)
       8:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
; 	nh_type = parse_ethhdr(&nh, data_end, &eth);
       9:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      10:	bf a1 00 00 00 00 00 00	r1 = r10
;     void *data_end = (void *)(long)ctx->data_end;
      11:	07 01 00 00 d0 ff ff ff	r1 += -48
      12:	bf a3 00 00 00 00 00 00	r3 = r10
      13:	07 03 00 00 d8 ff ff ff	r3 += -40
; 	nh_type = parse_ethhdr(&nh, data_end, &eth);
      14:	85 10 00 00 ff ff ff ff	call -1
      15:	63 0a cc ff 00 00 00 00	*(u32 *)(r10 - 52) = r0
; 	if (nh_type != bpf_htons(ETH_P_IPV6))
      16:	61 a1 cc ff 00 00 00 00	r1 = *(u32 *)(r10 - 52)
      17:	15 01 04 00 86 dd 00 00	if r1 == 56710 goto +4 <LBB4_2>
      18:	05 00 00 00 00 00 00 00	goto +0 <LBB4_1>

0000000000000098 <LBB4_1>:
      19:	b7 01 00 00 01 00 00 00	r1 = 1
;         return XDP_DROP;
      20:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      21:	05 00 14 00 00 00 00 00	goto +20 <LBB4_5>

00000000000000b0 <LBB4_2>:
; 	nh_type = parse_iphdr(&nh, data_end, &iph);
      22:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      23:	bf a1 00 00 00 00 00 00	r1 = r10
      24:	07 01 00 00 d0 ff ff ff	r1 += -48
      25:	bf a3 00 00 00 00 00 00	r3 = r10
      26:	07 03 00 00 c0 ff ff ff	r3 += -64
      27:	85 10 00 00 ff ff ff ff	call -1
      28:	63 0a cc ff 00 00 00 00	*(u32 *)(r10 - 52) = r0
; 	if (nh_type != 0)
      29:	61 a1 cc ff 00 00 00 00	r1 = *(u32 *)(r10 - 52)
      30:	15 01 04 00 00 00 00 00	if r1 == 0 goto +4 <LBB4_4>
      31:	05 00 00 00 00 00 00 00	goto +0 <LBB4_3>

0000000000000100 <LBB4_3>:
      32:	b7 01 00 00 01 00 00 00	r1 = 1
; 		return XDP_DROP;
      33:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      34:	05 00 07 00 00 00 00 00	goto +7 <LBB4_5>

0000000000000118 <LBB4_4>:
; 	swap_src_dst_mac(eth);
      35:	79 a1 d8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 40)
      36:	85 10 00 00 ff ff ff ff	call -1
; 	swap_src_dst_ipv4(iph);
      37:	79 a1 c0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 64)
      38:	85 10 00 00 ff ff ff ff	call -1
      39:	b7 01 00 00 01 00 00 00	r1 = 1
;     return XDP_DROP;
      40:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      41:	05 00 00 00 00 00 00 00	goto +0 <LBB4_5>

0000000000000150 <LBB4_5>:
; }
      42:	61 a0 fc ff 00 00 00 00	r0 = *(u32 *)(r10 - 4)
      43:	95 00 00 00 00 00 00 00	exit
