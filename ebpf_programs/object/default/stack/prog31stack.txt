
ebpf_programs/object/default/prog31.bpf.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <updating_map>:
; void updating_map(__u32 key) {
       0:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
;     __u32* value = bpf_map_lookup_elem(&xdp_map, &key);
       1:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       3:	7b 1a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r1
       4:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
       5:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       7:	bf a2 00 00 00 00 00 00	r2 = r10
       8:	07 02 00 00 fc ff ff ff	r2 += -4
       9:	7b 2a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r2
      10:	8d 00 00 00 03 00 00 00	callx r3
      11:	79 a2 d8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 40)
      12:	79 a1 e0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 32)
      13:	7b 0a f0 ff 00 00 00 00	*(u64 *)(r10 - 16) = r0
;     *value = *value + 1;
      14:	79 a4 f0 ff 00 00 00 00	r4 = *(u64 *)(r10 - 16)
      15:	61 43 00 00 00 00 00 00	r3 = *(u32 *)(r4 + 0)
      16:	07 03 00 00 01 00 00 00	r3 += 1
      17:	63 34 00 00 00 00 00 00	*(u32 *)(r4 + 0) = r3
;     struct value *value2 = bpf_map_lookup_elem(&map_value, &key);
      18:	79 13 00 00 00 00 00 00	r3 = *(u64 *)(r1 + 0)
      19:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      21:	8d 00 00 00 03 00 00 00	callx r3
      22:	7b 0a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r0
;     value2->testing = *value;
      23:	79 a1 f0 ff 00 00 00 00	r1 = *(u64 *)(r10 - 16)
      24:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
      25:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      26:	63 12 00 00 00 00 00 00	*(u32 *)(r2 + 0) = r1
;     value2->testing2 = value2->testing * (*value);
      27:	79 a2 e8 ff 00 00 00 00	r2 = *(u64 *)(r10 - 24)
      28:	61 21 00 00 00 00 00 00	r1 = *(u32 *)(r2 + 0)
      29:	79 a3 f0 ff 00 00 00 00	r3 = *(u64 *)(r10 - 16)
      30:	61 33 00 00 00 00 00 00	r3 = *(u32 *)(r3 + 0)
      31:	2f 31 00 00 00 00 00 00	r1 *= r3
      32:	63 12 04 00 00 00 00 00	*(u32 *)(r2 + 4) = r1
; }
      33:	95 00 00 00 00 00 00 00	exit

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
; int xdp_prog(struct xdp_md *ctx) {
       0:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
;     __u32 data_start = ctx->data;
       1:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
       2:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
       3:	63 1a f4 ff 00 00 00 00	*(u32 *)(r10 - 12) = r1
;     __u32 data_end = ctx->data_end;
       4:	79 a1 f8 ff 00 00 00 00	r1 = *(u64 *)(r10 - 8)
       5:	61 11 04 00 00 00 00 00	r1 = *(u32 *)(r1 + 4)
       6:	63 1a f0 ff 00 00 00 00	*(u32 *)(r10 - 16) = r1
;     if(data_end > data_start) {
       7:	61 a2 f0 ff 00 00 00 00	r2 = *(u32 *)(r10 - 16)
       8:	61 a1 f4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 12)
       9:	3d 21 06 00 00 00 00 00	if r1 >= r2 goto +6 <LBB1_2>
      10:	05 00 00 00 00 00 00 00	goto +0 <LBB1_1>

0000000000000058 <LBB1_1>:
      11:	b7 01 00 00 00 00 00 00	r1 = 0
;         __u32 key = 0;
      12:	63 1a ec ff 00 00 00 00	*(u32 *)(r10 - 20) = r1
;         updating_map(key);
      13:	61 a1 ec ff 00 00 00 00	r1 = *(u32 *)(r10 - 20)
      14:	85 10 00 00 ff ff ff ff	call -1
;     }
      15:	05 00 00 00 00 00 00 00	goto +0 <LBB1_2>

0000000000000080 <LBB1_2>:
      16:	b7 00 00 00 01 00 00 00	r0 = 1
;     return XDP_DROP; // Drop all packets
      17:	95 00 00 00 00 00 00 00	exit
