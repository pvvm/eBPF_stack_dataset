
ebpf_programs/object/optimized/prog35.bpf.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <helping_func>:
; __u32 helping_func(__u32 valiable) {
       0:	bf 10 00 00 00 00 00 00	r0 = r1
;     if(valiable * 2 > 500)
       1:	67 01 00 00 01 00 00 00	r1 <<= 1
       2:	67 01 00 00 20 00 00 00	r1 <<= 32
       3:	77 01 00 00 20 00 00 00	r1 >>= 32
       4:	25 01 01 00 f4 01 00 00	if r1 > 500 goto +1 <LBB0_2>
       5:	b7 00 00 00 00 00 00 00	r0 = 0

0000000000000030 <LBB0_2>:
; }
       6:	95 00 00 00 00 00 00 00	exit

0000000000000038 <second_func>:
; __u32 second_func(__u32 number) {
       7:	bf 10 00 00 00 00 00 00	r0 = r1
;     return number * 10;
       8:	27 00 00 00 0a 00 00 00	r0 *= 10
       9:	95 00 00 00 00 00 00 00	exit

0000000000000050 <updating_map>:
;     *value = *value + 1;
      10:	61 13 00 00 00 00 00 00	r3 = *(u32 *)(r1 + 0)
      11:	07 03 00 00 01 00 00 00	r3 += 1
      12:	63 31 00 00 00 00 00 00	*(u32 *)(r1 + 0) = r3
;     value2->testing = *value;
      13:	63 32 00 00 00 00 00 00	*(u32 *)(r2 + 0) = r3
;     value2->testing2 = value2->testing * (*value);
      14:	61 14 00 00 00 00 00 00	r4 = *(u32 *)(r1 + 0)
      15:	2f 34 00 00 00 00 00 00	r4 *= r3
      16:	63 42 04 00 00 00 00 00	*(u32 *)(r2 + 4) = r4
;     if(*value > 5) {
      17:	61 13 00 00 00 00 00 00	r3 = *(u32 *)(r1 + 0)
      18:	b7 04 00 00 06 00 00 00	r4 = 6
      19:	2d 34 08 00 00 00 00 00	if r4 > r3 goto +8 <LBB2_4>
;     if(valiable * 2 > 500)
      20:	bf 32 00 00 00 00 00 00	r2 = r3
      21:	67 02 00 00 01 00 00 00	r2 <<= 1
      22:	67 02 00 00 20 00 00 00	r2 <<= 32
      23:	77 02 00 00 20 00 00 00	r2 >>= 32
      24:	25 02 01 00 f4 01 00 00	if r2 > 500 goto +1 <LBB2_3>
      25:	b7 03 00 00 00 00 00 00	r3 = 0

00000000000000d0 <LBB2_3>:
;         *value = helping_func(*value);
      26:	63 31 00 00 00 00 00 00	*(u32 *)(r1 + 0) = r3
      27:	05 00 02 00 00 00 00 00	goto +2 <LBB2_5>

00000000000000e0 <LBB2_4>:
;     return number * 10;
      28:	27 03 00 00 0a 00 00 00	r3 *= 10
;         value2->testing = second_func(*value);
      29:	63 32 00 00 00 00 00 00	*(u32 *)(r2 + 0) = r3

00000000000000f0 <LBB2_5>:
; }
      30:	95 00 00 00 00 00 00 00	exit

Disassembly of section xdp:

0000000000000000 <xdp_prog>:
;     __u32 data_end = ctx->data_end;
       0:	61 12 04 00 00 00 00 00	r2 = *(u32 *)(r1 + 4)
;     __u32 data_start = ctx->data;
       1:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
;     if(data_end > data_start) {
       2:	3d 21 21 00 00 00 00 00	if r1 >= r2 goto +33 <LBB3_6>
       3:	b7 01 00 00 00 00 00 00	r1 = 0
;         __u32 key = 0;
       4:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
       5:	bf a7 00 00 00 00 00 00	r7 = r10
       6:	07 07 00 00 fc ff ff ff	r7 += -4
;         __u32* value = bpf_map_lookup_elem(&xdp_map, &key);
       7:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
       9:	bf 72 00 00 00 00 00 00	r2 = r7
      10:	85 00 00 00 01 00 00 00	call 1
      11:	bf 06 00 00 00 00 00 00	r6 = r0
;         struct value *value2 = bpf_map_lookup_elem(&map_value, &key);
      12:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      14:	bf 72 00 00 00 00 00 00	r2 = r7
      15:	85 00 00 00 01 00 00 00	call 1
;     *value = *value + 1;
      16:	61 61 00 00 00 00 00 00	r1 = *(u32 *)(r6 + 0)
      17:	07 01 00 00 01 00 00 00	r1 += 1
      18:	63 16 00 00 00 00 00 00	*(u32 *)(r6 + 0) = r1
;     value2->testing = *value;
      19:	63 10 00 00 00 00 00 00	*(u32 *)(r0 + 0) = r1
;     value2->testing2 = value2->testing * (*value);
      20:	61 62 00 00 00 00 00 00	r2 = *(u32 *)(r6 + 0)
      21:	2f 12 00 00 00 00 00 00	r2 *= r1
      22:	63 20 04 00 00 00 00 00	*(u32 *)(r0 + 4) = r2
;     if(*value > 5) {
      23:	61 61 00 00 00 00 00 00	r1 = *(u32 *)(r6 + 0)
      24:	b7 02 00 00 06 00 00 00	r2 = 6
      25:	2d 12 08 00 00 00 00 00	if r2 > r1 goto +8 <LBB3_5>
;     if(valiable * 2 > 500)
      26:	bf 12 00 00 00 00 00 00	r2 = r1
      27:	67 02 00 00 01 00 00 00	r2 <<= 1
      28:	67 02 00 00 20 00 00 00	r2 <<= 32
      29:	77 02 00 00 20 00 00 00	r2 >>= 32
      30:	25 02 01 00 f4 01 00 00	if r2 > 500 goto +1 <LBB3_4>
      31:	b7 01 00 00 00 00 00 00	r1 = 0

0000000000000100 <LBB3_4>:
;         *value = helping_func(*value);
      32:	63 16 00 00 00 00 00 00	*(u32 *)(r6 + 0) = r1
      33:	05 00 02 00 00 00 00 00	goto +2 <LBB3_6>

0000000000000110 <LBB3_5>:
;     return number * 10;
      34:	27 01 00 00 0a 00 00 00	r1 *= 10
;         value2->testing = second_func(*value);
      35:	63 10 00 00 00 00 00 00	*(u32 *)(r0 + 0) = r1

0000000000000120 <LBB3_6>:
;     return XDP_DROP; // Drop all packets
      36:	b7 00 00 00 01 00 00 00	r0 = 1
      37:	95 00 00 00 00 00 00 00	exit
