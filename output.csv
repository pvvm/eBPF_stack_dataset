Index,Code
1,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
2,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable = 5; variable += 4; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
3,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u16 variable = 5; variable += 12; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
4,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u64 variable = 0; variable += 50; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
5,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 variable = 100; variable += 51; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
6,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable1 = 5; __u64 variable2; variable2 = 5 + variable1; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
7,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable1 = 1; __u64 variable2; __u32 a = 20; if(a > variable1) { variable2 = 5 + variable1; } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
8,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable1 = 1; __u64 variable2; __u32 a = 20; if(a > variable1) { variable2 = 5 + variable1; __u32 b = a; b *= 123; if(b > 1000) { __u8 c = 1; } } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
9,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable1 = 1; __u64 variable2; __u32 a = 20; if(a > variable1) { variable2 = 5 + variable1; __u32 b = a; b *= 123; if(b > 1000) { __u8 c = 1; } } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
10,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; this += -1; if(this > value) { value = 5 + this; __u32 testing = 123; testing *= 123; if(this > 1000) { testing = 1; } } __u8 a = 20; a += this; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
11,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 variable = 1; __u8 variable2 = variable + 5; __u16 trying12 = 1; this += -1;  if(variable > value) { return XDP_PASS; } else if(this && variable2) { this *= 12; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
12,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u64 variable = 1; __u8 variable2 = variable + 5; __u16 trying12 = 1; this += -1;  if(variable > value) { return XDP_PASS; } else if(this && variable2) { this *= 12; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
13,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u8 a; __u8 b; __u8 c; __u16 d; __u64 e; };  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u64 variable = 1; __u8 variable2 = variable + 5; __u16 trying12 = 1; this += -1;  if(variable > value) { return XDP_PASS; } else if(this && variable2) { this *= 12; struct testing struct_instance; struct_instance.a = value; struct_instance.c = struct_instance.a * 2; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
14,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u8 a; __u8 b; __u8 c; __u16 d; __u64 e; };  struct str_testando { __u8 hello; __u64 trying_out; };  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u64 variable = 1; __u8 variable2 = variable + 5; __u16 trying12 = 1; this += -1;  if(variable > value) { struct str_testando str_inst_2; str_inst_2.hello = this; str_inst_2.trying_out = variable2 * 1000; return XDP_PASS; } else if(this && variable2) { this *= 12; struct testing struct_instance; struct_instance.a = value; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
15,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; __u16 trying12 = 1; this += -1;  if(you_are_cool > value) { struct str_testando str_inst_2; str_inst_2.hello = this; str_inst_2.trying_out = trying12 * 1000; return XDP_PASS; } else if((this && 1) || trying12) { this *= 12; struct testing struct_instance; struct_instance.amem = value; struct_instance.example = struct_instance.amem * this; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
16,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; __u16 trying12 = 1; this += -1;  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end < data_start) return XDP_DROP; struct xdp_md *copy = ctx;  __u32 rx_index = copy->rx_queue_index;  if(you_are_cool > value) { struct str_testando str_inst_2; str_inst_2.hello = this; str_inst_2.trying_out = trying12 * 1000; return XDP_PASS; } else if(this && (1 || trying12)) { this *= 12; struct testing struct_instance; struct_instance.amem = value; struct_instance.example = struct_instance.amem * this; }  if(rx_index != 0) this = 0;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
17,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  void helper() { struct str_testando str_inst_2; str_inst_2.hello = 12; str_inst_2.trying_out = 10 * 1000; str_inst_2.hello = str_inst_2.trying_out - str_inst_2.trying_out + 1; return; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; __u16 trying12 = 1; this += -1;  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end < data_start) return XDP_DROP; struct xdp_md *copy = ctx;  __u32 rx_index = copy->rx_queue_index;  if(you_are_cool > value) { helper(); return XDP_PASS; }  if(rx_index != 0) this = 0;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
18,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u16 helper() { __u8 g = 12; __u16 uga = g * 2; return uga; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; __u16 trying12 = 1; this += -1;  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end < data_start) return XDP_DROP; struct xdp_md *copy = ctx;  __u32 rx_index = copy->rx_queue_index;  if(you_are_cool > value) { __u16 helper_return = helper(); return XDP_PASS; }  if(rx_index != 0) this = 0;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
19,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  void testing_func(__u32 *value) { if(*value > 123) { *value = 10; } return; }  __u16 helper() { __u8 g = 12; __u16 uga = g * 2; __u32 value; value = 500; testing_func(&value); if(value > uga) { return uga; } return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; this = this + -1;  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end < data_start) return XDP_DROP; struct xdp_md *copy = ctx;  __u32 rx_index = copy->rx_queue_index;  if(you_are_cool > value) { __u16 helper_return = helper(); helper_return = helper_return + 1;; return XDP_PASS; }  if(rx_index != 0) this = 0;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
20,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u8 helper() { __u8 var = 123; if(var != 100) { __u32 value2 = 3; value2 *= 2; var = value2 - value2 + 1; } return var; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u64 val2 = value + 1; this += -1; if(this > value) { value = 5 + this; __u32 testing = 123; testing *= 123; if(this > 1000) { testing = 1; } helper(); } __u8 a = 20; a += this; a += val2;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
21,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function5(__u32 value) { value = value + 1; return value; }  __u32 function4(__u32 value) { value = value + 1; function5(value); return value; }  __u32 function3(__u32 value) { value = value + 1; function4(value); return value; }  __u32 function2(__u32 value) { value = value + 1; function3(value); return value; }  __u32 function1(__u32 value) { value = value + 1; function2(value); return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
22,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function3(__u32 value) { value = value + 1; return value; }  __u32 function4(__u16 trying) { if(trying < 10) { return trying; } return 0; }  __u32 function2(__u32 value) { value = value + 1; __u16 roedor = 5; value = roedor + 1; function3(value); function4(roedor); return value; }  __u32 function1(__u32 value) { __u8 xandao = 2; value = value + 1; function2(value); return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
23,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function3(__u32 value) { value = value + 1; return value; }  __u32 function2(__u32 value) { value = value + 1; __u16 roedor = 5; value = roedor + 1; function3(value); return value; }  __u32 function1(__u32 value) { value = value + 1; function2(value); return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
24,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function1(__u32 value) { __u8 xandao = 2; value = value + 1; return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
25,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u32 function4(__u16 trying) { if(trying < 10) { return trying; } return 0; }  __u32 helping(__u32 value) { value = value + 1; __u8 afago = 1; __u32 argument; if(afago) argument = afago; else argument = value; function4(argument); return value; }  __u32 function2(__u32 value) { value = value + 1; __u16 roedor = 5; value = roedor + 1; helping(value); function4(roedor); return value; }  __u32 function1(__u32 value) { __u8 xandao = 2; value = value + 1; function2(value); return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
26,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u32 function4(__u16 trying) { if(trying < 10) { return trying; } return 0; }  __u32 helping(__u32 value) { value = value + 1; __u8 afago = 1; __u16 argument; if(afago) argument = afago; else argument = value; function4(argument); return value; }  __u32 cool(__u32 value) { value = value + 1; helping(value); return value; }  __u32 helping_hand(__u32 value) { __u8 xandao = 2; value = value + 1; cool(value); return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; helping_hand(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
27,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u32 function4(__u32 trying) { if(trying < 10) { return trying; } return 0; }  __u32 helping(__u32 value) { value = value + 1; __u8 afago = 1; __u16 argument; if(afago) argument = afago; else argument = value; function4(argument); return value; }  __u32 cool(__u32 value) { value = value + 1; helping(value); return value; }  __u32 helping_hand(__u32 value) { __u8 xandao = 2; value = value + 1; cool(value); return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; value = helping_hand(value);  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start && value) { function4(value); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
28,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u8 check_helper(__u32 value, __u16 auxiliar) { if(value > auxiliar) return 1; else return 0; }  __u32 helping_hand(__u32 value, __u16 auxiliar) { value = value + auxiliar; __u8 returned = check_helper(value, auxiliar); if(returned) return value - auxiliar; else return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; value = helping_hand(value, 25);  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start && value) { function4(value); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
29,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); *value = *value + 1; } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
30,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); *value = *value + 1;  struct value *value2 = bpf_map_lookup_elem(&map_value, &key); value2->testing = *value; value2->testing2 = value2->testing * (*value); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
31,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  void updating_map(__u32 key) { __u32* value = bpf_map_lookup_elem(&xdp_map, &key); *value = *value + 1; struct value *value2 = bpf_map_lookup_elem(&map_value, &key); value2->testing = *value; value2->testing2 = value2->testing * (*value); }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; updating_map(key); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
32,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  void updating_map(__u32 *value, struct value *value2) { *value = *value + 1; value2->testing = *value; value2->testing2 = value2->testing * (*value); }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); struct value *value2 = bpf_map_lookup_elem(&map_value, &key); updating_map(value, value2); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
33,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  __u32 helping_func(__u32 valiable) { if(valiable * 2 > 500) return valiable; else return 0; }  void updating_map(__u32 *value, struct value *value2) { *value = *value + 1; value2->testing = *value; value2->testing2 = value2->testing * (*value); if(*value > 5) { *value = helping_func(*value); } }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); struct value *value2 = bpf_map_lookup_elem(&map_value, &key); updating_map(value, value2); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
34,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  __u32 helping_func(__u32 valiable) { if(valiable * 2 > 500) return valiable; else return 0; }  __u32 second_func(__u32 number) { return number * 10; }  void updating_map(__u32 *value, struct value *value2) { *value = *value + 1; value2->testing = *value; value2->testing2 = value2->testing * (*value); if(*value > 5) { *value = helping_func(*value); } else { value2->testing = second_func(*value); } }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); struct value *value2 = bpf_map_lookup_elem(&map_value, &key); updating_map(value, value2); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
35,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  __u32 helping_func(__u32 valiable) { if(valiable * 2 > 500) return valiable; else return 0; }  __u32 second_func(__u32 number) { return number * 10; }  void updating_map(__u32 *value, struct value *value2) { *value = *value + 1; value2->testing = *value; value2->testing2 = value2->testing * (*value); if(*value > 5) { *value = helping_func(*value); } else { value2->testing = second_func(*value); } }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); struct value *value2 = bpf_map_lookup_elem(&map_value, &key); updating_map(value, value2);  helping_func(*value); second_func(value2->testing2); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
36,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");   __u32 multiply_ten(__u32 number) { return number * 10; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u64 value = 1; __u8 value1 = 2; __u16 value2 = 3; __u8 value3 = 4; __u32 value4 = 5;  __u64 total = value + value1 + value2 + value3 + value4; total = multiply_ten(total);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
37,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h>  struct hdr_cursor { void *pos; };   static __always_inline int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  /* Byte-count bounds check; check if current pointer + size of header * is after data_end. */ if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; /* network-byte-order */ }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  /* Default action XDP_PASS, imply everything we couldn't parse, or that * we don't want to deal with, we just pass up the stack and let the * kernel deal with it. */ __u32 action = XDP_PASS; /* Default action */  /* These keep track of the next header type and iterator pointer */ struct hdr_cursor nh; int nh_type;  /* Start next header cursor position at data start */ nh.pos = data;  /* Packet parsing in steps: Get each header one at a time, aborting if * parsing fails. Each helper function does sanity checking (is the * header type in the packet correct?), and bounds checking. */ nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
38,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   static __always_inline int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }  static __always_inline int parse_ip6hdr(struct hdr_cursor *nh, void *data_end, struct ipv6hdr **ip6hdr) { struct ipv6hdr *ip6h = nh->pos;  if (ip6h + 1 > data_end) return -1;  nh->pos = ip6h + 1; *ip6hdr = ip6h;  return ip6h->nexthdr; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct ipv6hdr *ip6h; struct icmp6hdr *icmp6h;  nh_type = parse_ip6hdr(&nh, data_end, &ip6h); if (nh_type != IPPROTO_ICMPV6) return XDP_DROP;   return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
39,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   static __always_inline int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }  static __always_inline int parse_ip6hdr(struct hdr_cursor *nh, void *data_end, struct ipv6hdr **ip6hdr) { struct ipv6hdr *ip6h = nh->pos;  if (ip6h + 1 > data_end) return -1;  nh->pos = ip6h + 1; *ip6hdr = ip6h;  return ip6h->nexthdr; }  static __always_inline int parse_icmp6hdr(struct hdr_cursor *nh, void *data_end, struct icmp6hdr **icmp6hdr) { struct icmp6hdr *icmp6h = nh->pos;  if (icmp6h + 1 > data_end) return -1;  nh->pos   = icmp6h + 1; *icmp6hdr = icmp6h;  return icmp6h->icmp6_type; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct ipv6hdr *ip6h; struct icmp6hdr *icmp6h;  nh_type = parse_ip6hdr(&nh, data_end, &ip6h); if (nh_type != IPPROTO_ICMPV6) return XDP_DROP;  nh_type = parse_icmp6hdr(&nh, data_end, &icmp6h); if (nh_type != ICMPV6_ECHO_REQUEST) return XDP_DROP;  if (bpf_ntohs(icmp6h->icmp6_sequence) == 0) return XDP_DROP;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
40,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   static __always_inline int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }   static __always_inline int parse_iphdr(struct hdr_cursor *nh, void *data_end, struct iphdr **iphdr) { struct iphdr *iph = nh->pos; int hdrsize;  if (iph + 1 > data_end) return -1;  hdrsize = iph->ihl * 4;  if(hdrsize < sizeof(*iph)) return -1;  if (nh->pos + hdrsize > data_end) return -1;  nh->pos += hdrsize; *iphdr = iph;  return iph->protocol; }   SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct iphdr *iph; struct icmphdr *icmph;  nh_type = parse_iphdr(&nh, data_end, &iph); if (nh_type != 0) return XDP_DROP;   return XDP_DROP; }  char LICENSE[] SEC(""license"") = ""GPL"";"
41,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   static __always_inline int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }   static __always_inline int parse_iphdr(struct hdr_cursor *nh, void *data_end, struct iphdr **iphdr) { struct iphdr *iph = nh->pos; int hdrsize;  if (iph + 1 > data_end) return -1;  hdrsize = iph->ihl * 4;  if(hdrsize < sizeof(*iph)) return -1;  if (nh->pos + hdrsize > data_end) return -1;  nh->pos += hdrsize; *iphdr = iph;  return iph->protocol; }  static __always_inline int parse_icmphdr(struct hdr_cursor *nh, void *data_end, struct icmphdr **icmphdr) { struct icmphdr *icmph = nh->pos;  if (icmph + 1 > data_end) return -1;  nh->pos  = icmph + 1; *icmphdr = icmph;  return icmph->type; }   SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct iphdr *iph; struct icmphdr *icmph;  nh_type = parse_iphdr(&nh, data_end, &iph); if (nh_type != 0) return XDP_DROP;  nh_type = parse_icmphdr(&nh, data_end, &icmph); if (nh_type != ICMP_ECHO) return XDP_DROP;  return XDP_DROP; }  char LICENSE[] SEC(""license"") = ""GPL"";"
42,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }   int parse_iphdr(struct hdr_cursor *nh, void *data_end, struct iphdr **iphdr) { struct iphdr *iph = nh->pos; int hdrsize;  if (iph + 1 > data_end) return -1;  hdrsize = iph->ihl * 4;  if(hdrsize < sizeof(*iph)) return -1;  if (nh->pos + hdrsize > data_end) return -1;  nh->pos += hdrsize; *iphdr = iph;  return iph->protocol; }  void swap_src_dst_mac(struct ethhdr *eth) { __u8 h_tmp[ETH_ALEN];  __builtin_memcpy(h_tmp, eth->h_source, ETH_ALEN); __builtin_memcpy(eth->h_source, eth->h_dest, ETH_ALEN); __builtin_memcpy(eth->h_dest, h_tmp, ETH_ALEN); }   SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct iphdr *iph;  nh_type = parse_iphdr(&nh, data_end, &iph); if (nh_type != 0) return XDP_DROP;  swap_src_dst_mac(eth);  return XDP_DROP; }  char LICENSE[] SEC(""license"") = ""GPL"";"
43,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }   int parse_iphdr(struct hdr_cursor *nh, void *data_end, struct iphdr **iphdr) { struct iphdr *iph = nh->pos; int hdrsize;  if (iph + 1 > data_end) return -1;  hdrsize = iph->ihl * 4;  if(hdrsize < sizeof(*iph)) return -1;  if (nh->pos + hdrsize > data_end) return -1;  nh->pos += hdrsize; *iphdr = iph;  return iph->protocol; }  void swap_src_dst_mac(struct ethhdr *eth) { __u8 h_tmp[ETH_ALEN];  __builtin_memcpy(h_tmp, eth->h_source, ETH_ALEN); __builtin_memcpy(eth->h_source, eth->h_dest, ETH_ALEN); __builtin_memcpy(eth->h_dest, h_tmp, ETH_ALEN); }  void swap_src_dst_ipv4(struct iphdr *iphdr) { __be32 tmp = iphdr->saddr;  iphdr->saddr = iphdr->daddr; iphdr->daddr = tmp; }   SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct iphdr *iph;  nh_type = parse_iphdr(&nh, data_end, &iph); if (nh_type != 0) return XDP_DROP;  swap_src_dst_mac(eth);  swap_src_dst_ipv4(iph);  return XDP_DROP; }  char LICENSE[] SEC(""license"") = ""GPL"";"
44,"/* SPDX-License-Identifier: GPL-2.0 */  #include <linux/bpf.h>  #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_XSKMAP); __type(key, __u32); __type(value, __u32); __uint(max_entries, 64); } xsks_map SEC("".maps"");  struct { __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 64); } xdp_stats_map SEC("".maps"");  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { int index = ctx->rx_queue_index; __u32 *pkt_count;  pkt_count = bpf_map_lookup_elem(&xdp_stats_map, &index); if (pkt_count) {  /* We pass every other packet */ if ((*pkt_count)++ & 1) return XDP_PASS; }  /* A set entry here means that the correspnding queue_id * has an active AF_XDP socket bound to it. */ if (bpf_map_lookup_elem(&xsks_map, &index)) return bpf_redirect_map(&xsks_map, index, 0);  return XDP_PASS; }  char _license[] SEC(""license"") = ""GPL"";"
45,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h>  #define MAX_NUMBER_CORES 8  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u64); __uint(max_entries, MAX_NUMBER_CORES); } common_array SEC("".maps"");  struct info { __u64 latency; __u64 counter; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct info); __uint(max_entries, MAX_NUMBER_CORES); } info_array SEC("".maps"");  static __always_inline int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0;  struct info new_value; new_value.latency = value->latency + (finish_time - arrival_time); new_value.counter = value->counter + 1; bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);  return 1; }   static __always_inline int lookup_map (int key, void * map_pointer) { __u64 * value = bpf_map_lookup_elem(map_pointer, &key);  if(!value) return 0;  *value += 1;  return 1; }   SEC(""xdp"") int  xdp_prog(struct xdp_md *ctx) { __u32 cpu = bpf_get_smp_processor_id();  __u64 arrival_time = bpf_ktime_get_ns();  lookup_map(cpu, &common_array);  __u64 finish_time = bpf_ktime_get_ns(); if(!update_info(arrival_time, finish_time, cpu)) { bpf_printk(""Error while looking up timer map""); }  return XDP_DROP; }  char _license[] SEC(""license"") = ""GPL"";"
46,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h>  #define MAX_NUMBER_CORES 8  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u64); __uint(max_entries, MAX_NUMBER_CORES); } common_array SEC("".maps"");  struct info { __u64 latency; __u64 counter; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct info); __uint(max_entries, MAX_NUMBER_CORES); } info_array SEC("".maps"");  static __always_inline int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0;  struct info new_value; new_value.latency = value->latency + (finish_time - arrival_time); new_value.counter = value->counter + 1; bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);  return 1; }   static __always_inline int lookup_map (int key, void * map_pointer) { __u64 * value = bpf_map_lookup_elem(map_pointer, &key);  if(!value) return 0;  *value += 1;  return 1; }  static __always_inline __u32 get_and_check_cpu_id() { __u32 cpu = bpf_get_smp_processor_id(); if(cpu >= 10) cpu -= 10; return cpu; }   SEC(""xdp"") int  xdp_prog(struct xdp_md *ctx) { __u32 cpu = get_and_check_cpu_id();  __u64 arrival_time = bpf_ktime_get_ns();  lookup_map(cpu, &common_array);  __u64 finish_time = bpf_ktime_get_ns(); if(!update_info(arrival_time, finish_time, cpu)) { return XDP_DROP; }  return XDP_DROP; }  char _license[] SEC(""license"") = ""GPL"";"
47,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h>  #define MAX_NUMBER_CORES 8  struct inner_map_queue { __uint(type, BPF_MAP_TYPE_QUEUE); __type(value, __u64); __uint(max_entries, 32); } inner_map_queue0 SEC("".maps""), inner_map_queue1 SEC("".maps""), inner_map_queue2 SEC("".maps""), inner_map_queue3 SEC("".maps""), inner_map_queue4 SEC("".maps""), inner_map_queue5 SEC("".maps""), inner_map_queue6 SEC("".maps""), inner_map_queue7 SEC("".maps"");  struct { __uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS); __uint(max_entries, MAX_NUMBER_CORES); __type(key, __u32); __array(values, struct inner_map_queue); } outer_map_queue SEC("".maps"") = { .values = {&inner_map_queue0, &inner_map_queue1, &inner_map_queue2, &inner_map_queue3, &inner_map_queue4, &inner_map_queue5, &inner_map_queue6, &inner_map_queue7} };  struct info { __u64 latency; __u64 counter; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct info); __uint(max_entries, MAX_NUMBER_CORES); } info_array SEC("".maps"");  static __always_inline int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0;  struct info new_value; new_value.latency = value->latency + (finish_time - arrival_time); new_value.counter = value->counter + 1; bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);  return 1; }   __u64 lookup_map_of_maps_queue (int key, __u64 counter/*, int iteration*/) {  struct inner_map_queue *map = bpf_map_lookup_elem(&outer_map_queue, &key);  if(!map) { return 0; }  __u64 value;  if(bpf_map_peek_elem(map, &value) < 0) { return 0; }  if(bpf_map_push_elem(map, &counter, BPF_EXIST) < 0) { return 0; }  return counter; }  __u64 get_counter (int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0; return value->counter; }  SEC(""xdp"") int  map_of_maps_queue(struct xdp_md *ctx) { __u32 cpu = bpf_get_smp_processor_id();  __u64 counter = get_counter(cpu);  __u64 arrival_time = bpf_ktime_get_ns();  lookup_map_of_maps_queue(cpu, counter);  __u64 finish_time = bpf_ktime_get_ns(); if(!update_info(arrival_time, finish_time, cpu)) { return XDP_DROP; }  return XDP_DROP; }  char _license[] SEC(""license"") = ""GPL"";"
48,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h>  #define MAX_NUMBER_CORES 8  struct map_locked_value { __u64 value; struct bpf_spin_lock lock; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct map_locked_value); __uint(max_entries, MAX_NUMBER_CORES); } lock_array SEC("".maps"");  struct info { __u64 latency; __u64 counter; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct info); __uint(max_entries, MAX_NUMBER_CORES); } info_array SEC("".maps"");  static __always_inline int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0;  struct info new_value; new_value.latency = value->latency + (finish_time - arrival_time); new_value.counter = value->counter + 1; bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);  return 1; }   static __always_inline int lookup_lock_map (int key) {  struct map_locked_value *lock_value = bpf_map_lookup_elem(&lock_array, &key);  if(!lock_value) { return 0; }  bpf_spin_lock(&lock_value->lock);  lock_value->value += 1; bpf_spin_unlock(&lock_value->lock);  return 1; }  SEC(""xdp"") int  lock_map(struct xdp_md *ctx) { int cpu = bpf_get_smp_processor_id();  __u64 arrival_time = bpf_ktime_get_ns();  lookup_lock_map(0);  __u64 finish_time = bpf_ktime_get_ns(); if(!update_info(arrival_time, finish_time, cpu)) { return XDP_DROP; }  return XDP_DROP; }  char _license[] SEC(""license"") = ""GPL"";"
49,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <time.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __uint(max_entries, 100); __uint(key_size, sizeof(__u32)); __uint(value_size, sizeof(__u32)); } array_map SEC("".maps"");   struct test_struct { __u64 test0; __u8 test1; __u8 test2; __u8 test3; __u8 test4; __u8 test5; __u8 test6; };  int test_function(struct test_struct var0, __u32 var1) { var0.test0 = var1; var0.test1 = var0.test0 * var1; var0.test2 = var0.test1 * var1; var0.test3 = var0.test2 * var1; var0.test4 = var0.test3 * var1; return var0.test4; }  int test_function3(var2, var3) { return var2 + var3; }  void test_function2() { __u8 var2 = 152; __u8 var3 = 143; __u16 var4 = 1; var2 = var3 + 123 + var2 + var4; const int key = 0; __u32 * teste = bpf_map_lookup_elem(&array_map, &key); const int key1 = 1; __u32 * teste1 = bpf_map_lookup_elem(&array_map, &key1); const int key2 = 2; __u32 * teste2 = bpf_map_lookup_elem(&array_map, &key2); const int key3 = 3; __u32 * teste3 = bpf_map_lookup_elem(&array_map, &key3); const int key4 = 4; __u32 * teste4 = bpf_map_lookup_elem(&array_map, &key4); const int key5 = 5; __u32 * teste5 = bpf_map_lookup_elem(&array_map, &key5); const int key6 = 6; __u32 * teste6 = bpf_map_lookup_elem(&array_map, &key6); if(!teste || !teste1 || !teste2 || !teste3 || !teste4 || !teste5 || !teste6) return;  var4 = test_function3(var2, var3);  int value = *teste; value = value + 53; return; }  SEC(""xdp"") int testing_stack(struct xdp_md *ctx) { volatile struct test_struct var0 = {0,0,0,0,0,0,0};  volatile __u64 var1 = 123;  var1 = test_function(var0, var1);  test_function2();  return 0; }  char _license[] SEC(""license"") = ""GPL"";"
50,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function1(__u32 value);  __u32 function7(__u32 value) { value = value + 1; function1(value); return value; }  __u32 function6(__u32 value) { value = value + 1; function7(value); return value; }  __u32 function5(__u32 value) { value = value + 1; function6(value); return value; }  __u32 function4(__u32 value) { value = value + 1; function5(value); return value; }  __u32 function3(__u32 value) { value = value + 1; return value; }  __u32 function2(__u32 value) { value = value + 1; __u16 roedor = 5; value = roedor + 1; function3(value); return value; }  __u32 function1(__u32 value) { value = value + 1; function2(value); return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value); function4(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";"
