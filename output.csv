Index,Code,Diagram
1,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> Total: 8 ]
2,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable = 5; variable += 4; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> variable -> 1 <br> Total: 9 ]
3,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u16 variable = 5; variable += 12; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> variable -> 2 <br> Total: 10 ]
4,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u64 variable = 0; variable += 50; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> variable -> 8 <br> Total: 16 ]
5,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 variable = 100; variable += 51; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> variable -> 4 <br> Total: 12 ]
6,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable1 = 5; __u64 variable2; variable2 = 5 + variable1; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> variable1 -> 1 + 7 <br> variable2 -> 8 <br> Total: 24 ]
7,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable1 = 1; __u64 variable2; __u32 a = 20; if(a > variable1) { variable2 = 5 + variable1; } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> variable1 -> 1 + 7 <br> variable2 -> 8 <br> a -> 4 <br> Total: 28 ]
8,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable1 = 1; __u64 variable2; __u32 a = 20; if(a > variable1) { variable2 = 5 + variable1; __u32 b = a; b *= 123; if(b > 1000) { __u8 c = 1; } } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> variable1 -> 1 + 7 <br> variable2 -> 8 <br> a -> 4 <br> b -> 4 <br> c -> 1 <br> Total: 33 ]
9,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u8 variable1 = 1; __u16 variable2; __u32 a = 20; if(a > variable1) { variable2 = 5 + variable1; __u32 b = a; b *= 123; if(b > 1000) { __u8 c = 1; } } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> variable1 -> 1 + 1 <br> variable2 -> 2 <br> a -> 4 <br> b -> 4 <br> c -> 1 <br> Total: 21 ]
10,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; this += -1; if(this > value) { value = 5 + this; __u32 testing = 123; testing *= 123; if(this > 1000) { testing = 1; } } __u8 a = 20; a += this; return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 + 3 <br> testing -> 4 <br> a -> 1 <br> Total: 21 ]
11,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 variable = 1; __u8 variable2 = variable + 5; __u16 trying12 = 1; this += -1;  if(variable > value) { return XDP_PASS; } else if(this && variable2) { this *= 12; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 <br> variable -> 1 <br> variable2 -> 1 + 1 <br> trying12 -> 2 <br> return -> 4 + 4 <br> Total: 26 ]
12,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u64 variable = 1; __u8 variable2 = variable + 5; __u16 trying12 = 1; this += -1;  if(variable > value) { return XDP_PASS; } else if(this && variable2) { this *= 12; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 + 3 <br> variable -> 8 <br> variable2 -> 1 + 1 <br> trying12 -> 2 <br> return -> 4 + 4 <br> Total: 36 ]
13,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u8 a; __u8 b; __u8 c; __u16 d; __u64 e; };  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u64 variable = 1; __u8 variable2 = variable + 5; __u16 trying12 = 1; this += -1;  if(variable > value) { return XDP_PASS; } else if(this && variable2) { this *= 12; struct testing struct_instance; struct_instance.a = value; struct_instance.c = struct_instance.a * 2; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 + 3 <br> variable -> 8 <br> variable2 -> 1 + 1 <br> trying12 -> 2 <br> str_inst_2 -> 20 <br> return -> 4 + 4 <br> Total: 56 ]
14,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u8 a; __u8 b; __u8 c; __u16 d; __u64 e; };  struct str_testando { __u8 hello; __u64 trying_out; };  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u64 variable = 1; __u8 variable2 = variable + 5; __u16 trying12 = 1; this += -1;  if(variable > value) { struct str_testando str_inst_2; str_inst_2.hello = this; str_inst_2.trying_out = variable2 * 1000; return XDP_PASS; } else if(this && variable2) { this *= 12; struct testing struct_instance; struct_instance.a = value; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 + 3 <br> variable -> 8 <br> variable2 -> 1 + 1 <br> trying12 -> 2 <br> str_inst_2 -> 20 <br> struct_instance -> 16 <br> return -> 4 + 4 <br> Total: 72 ]
15,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; __u16 trying12 = 1; this += -1;  if(you_are_cool > value) { struct str_testando str_inst_2; str_inst_2.hello = this; str_inst_2.trying_out = trying12 * 1000; return XDP_PASS; } else if((this && 1) || trying12) { this *= 12; struct testing struct_instance; struct_instance.amem = value; struct_instance.example = struct_instance.amem * this; }  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 <br> you_are_cool -> 1 <br> trying12 -> 2 <br> str_inst_2 -> 16 <br> struct_instance -> 16 <br> return -> 4 + 4 <br> Total: 56 ]
16,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; __u16 trying12 = 1; this += -1;  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end < data_start) return XDP_DROP; struct xdp_md *copy = ctx;  __u32 rx_index = copy->rx_queue_index;  if(you_are_cool > value) { struct str_testando str_inst_2; str_inst_2.hello = this; str_inst_2.trying_out = trying12 * 1000; return XDP_PASS; } else if(this && (1 || trying12)) { this *= 12; struct testing struct_instance; struct_instance.amem = value; struct_instance.example = struct_instance.amem * this; }  if(rx_index != 0) this = 0;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 <br> you_are_cool -> 1 <br> trying12 -> 2 <br> data_start -> 4 <br> data_end -> 4 <br> copy -> 8 <br> rx_index -> 4 <br> str_inst_2 -> 20 <br> struct_instance -> 16 <br> return -> 4 + 4 <br> Total: 80 ]
17,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  void helper() { struct str_testando str_inst_2; str_inst_2.hello = 12; str_inst_2.trying_out = 10 * 1000; str_inst_2.hello = str_inst_2.trying_out - str_inst_2.trying_out + 1; return; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; __u16 trying12 = 1; this += -1;  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end < data_start) return XDP_DROP; struct xdp_md *copy = ctx;  __u32 rx_index = copy->rx_queue_index;  if(you_are_cool > value) { helper(); return XDP_PASS; }  if(rx_index != 0) this = 0;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 <br> you_are_cool -> 1 <br> trying12 -> 2 <br> data_start -> 4 <br> data_end -> 4 <br> copy -> 8 <br> rx_index -> 4 <br> return -> 4 + 4 <br> Total: 44 ] --> B  B[ <b> helper </b> <br> str_inst_2 -> 16 <br> Total: 16]
18,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u16 helper() { __u8 g = 12; __u16 uga = g * 2; return uga; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; __u16 trying12 = 1; this += -1;  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end < data_start) return XDP_DROP; struct xdp_md *copy = ctx;  __u32 rx_index = copy->rx_queue_index;  if(you_are_cool > value) { __u16 helper_return = helper(); return XDP_PASS; }  if(rx_index != 0) this = 0;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 <br> you_are_cool -> 1 <br> trying12 -> 2 <br> data_start -> 4 <br> data_end -> 4 <br> copy -> 8 <br> rx_index -> 4 <br> helper_return -> 2 <br> return -> 4 + 4 <br> Total: 46 ] --> B  B[ <b> helper </b> <br> g -> 1 + 1 <br> uga -> 2 <br> Total: 4]
19,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  void testing_func(__u32 *value) { if(*value > 123) { *value = 10; } return; }  __u16 helper() { __u8 g = 12; __u16 uga = g * 2; __u32 value; value = 500; testing_func(&value); if(value > uga) { return uga; } return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u8 you_are_cool = 1 + 5; this = this + -1;  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end < data_start) return XDP_DROP; struct xdp_md *copy = ctx;  __u32 rx_index = copy->rx_queue_index;  if(you_are_cool > value) { __u16 helper_return = helper(); helper_return = helper_return + 1;; return XDP_PASS; }  if(rx_index != 0) this = 0;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 <br> you_are_cool -> 1 + 2 <br> data_start -> 4 <br> data_end -> 4 <br> copy -> 8 <br> rx_index -> 4 <br> helper_return -> 2 <br> return -> 4 + 4 <br> Total: 46 ] --> B  B[ <b> helper </b> <br> g -> 1 + 1 <br> uga -> 2 + 2 <br> value -> 4 <br> return -> 2 <br> Total: 4] --> C  C[ <b> testing_fun </b> <br> value -> 8 <br> Total: 8]
20,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u8 helper() { __u8 var = 123; if(var != 100) { __u32 value2 = 3; value2 *= 2; var = value2 - value2 + 1; } return var; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 this = 1; __u8 value = 0; __u64 val2 = value + 1; this += -1; if(this > value) { value = 5 + this; __u32 testing = 123; testing *= 123; if(this > 1000) { testing = 1; } helper(); } __u8 a = 20; a += this; a += val2;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> this -> 4 <br> value -> 1 + 3 <br> val2 -> 8 <br> testing -> 4 <br> a -> 1 <br> Total: 29 ] --> B  B[ <b> helper </b> <br> var -> 1 + 3 <br> value2 -> 4 <br> Total: 8]
21,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function5(__u32 value) { value = value + 1; return value; }  __u32 function4(__u32 value) { value = value + 1; function5(value); return value; }  __u32 function3(__u32 value) { value = value + 1; function4(value); return value; }  __u32 function2(__u32 value) { value = value + 1; function3(value); return value; }  __u32 function1(__u32 value) { value = value + 1; function2(value); return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 4 <br> Total: 12 ] --> B  B[ <b> function1 </b> <br> value -> 4 <br> Total: 4] --> C  C[ <b> function2 </b> <br> value -> 4 <br> Total: 4] --> D  D[ <b> function3 </b> <br> value -> 4 <br> Total: 4] --> E  E[ <b> function4 </b> <br> value -> 4 <br> Total: 4] --> F  F[ <b> function5 </b> <br> value -> 4 <br> Total: 4]
22,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function3(__u32 value) { value = value + 1; return value; }  __u32 function4(__u16 trying) { if(trying < 10) { return trying; } return 0; }  __u32 function2(__u32 value) { value = value + 1; __u16 roedor = 5; value = roedor + 1; function3(value); function4(roedor); return value; }  __u32 function1(__u32 value) { __u8 xandao = 2; value = value + 1; function2(value); return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 4 <br> Total: 12 ] --> B  B[ <b> function1 </b> <br> value -> 4 <br> xandao -> 1 <br> Total: 5] --> C  C[ <b> function2 </b> <br> value -> 4 <br> roedor -> 2 <br> Total: 6] --> D C --> E  D[ <b> function3 </b> <br> value -> 4 <br> Total: 4]  E[ <b> function4 </b> <br> trying -> 2 <br> return -> 4 <br> Total: 6]
23,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function3(__u32 value) { value = value + 1; return value; }  __u32 function2(__u32 value) { value = value + 1; __u16 roedor = 5; value = roedor + 1; function3(value); return value; }  __u32 function1(__u32 value) { value = value + 1; function2(value); return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 4 <br> Total: 12 ] --> B  B[ <b> function1 </b> <br> value -> 4 <br> Total: 4] --> C  C[ <b> function2 </b> <br> value -> 4 <br> roedor -> 2 <br> Total: 6] --> D  D[ <b> function3 </b> <br> value -> 4 <br> Total: 4]
24,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function1(__u32 value) { __u8 xandao = 2; value = value + 1; return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 4 <br> Total: 12 ] --> B  B[ <b> function1 </b> <br> value -> 4 <br> xandao -> 1 <br> Total: 5]
25,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u32 function4(__u16 trying) { if(trying < 10) { return trying; } return 0; }  __u32 helping(__u32 value) { value = value + 1; __u8 afago = 1; __u32 argument; if(afago) argument = afago; else argument = value; function4(argument); return value; }  __u32 function2(__u32 value) { value = value + 1; __u16 roedor = 5; value = roedor + 1; helping(value); function4(roedor); return value; }  __u32 function1(__u32 value) { __u8 xandao = 2; value = value + 1; function2(value); return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 4 <br> Total: 12 ] --> B  B[ <b> function1 </b> <br> value -> 4 <br> xandao -> 1 <br> Total: 5] --> C  C[ <b> function2 </b> <br> value -> 4 <br> roedor -> 2 <br> Total: 6] --> D C --> E  D[ <b> helping </b> <br> value -> 4 <br> afago -> 1 + 3 <br> argument -> 4 <br> Total: 12] --> E  E[ <b> function4 </b> <br> trying -> 2 <br> return -> 4 <br> Total: 6]
26,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u32 function4(__u16 trying) { if(trying < 10) { return trying; } return 0; }  __u32 helping(__u32 value) { value = value + 1; __u8 afago = 1; __u16 argument; if(afago) argument = afago; else argument = value; function4(argument); return value; }  __u32 cool(__u32 value) { value = value + 1; helping(value); return value; }  __u32 helping_hand(__u32 value) { __u8 xandao = 2; value = value + 1; cool(value); return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; helping_hand(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 4 <br> Total: 12 ] --> B  B[ <b> helping_hand </b> <br> value -> 4 <br> xandao -> 1 <br> Total: 5] --> C  C[ <b> cool </b> <br> value -> 4 <br> Total: 4] --> D  D[ <b> helping </b> <br> value -> 4 <br> afago -> 1 + 3 <br> argument -> 4 <br> Total: 12] --> E  E[ <b> function4 </b> <br> trying -> 2 <br> return -> 4 <br> Total: 6]
27,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u32 function4(__u32 trying) { if(trying < 10) { return trying; } return 0; }  __u32 helping(__u32 value) { value = value + 1; __u8 afago = 1; __u16 argument; if(afago) argument = afago; else argument = value; function4(argument); return value; }  __u32 cool(__u32 value) { value = value + 1; helping(value); return value; }  __u32 helping_hand(__u32 value) { __u8 xandao = 2; value = value + 1; cool(value); return xandao; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; value = helping_hand(value);  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start && value) { function4(value); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 4 <br> data_start -> 4 <br> data_end -> 4 <br> Total: 20 ] --> B A --> E  B[ <b> helping_hand </b> <br> value -> 4 <br> xandao -> 1 <br> Total: 5] --> C  C[ <b> cool </b> <br> value -> 4 <br> Total: 4] --> D  D[ <b> helping </b> <br> value -> 4 <br> afago -> 1 + 1 <br> argument -> 2 <br> Total: 8] --> E  E[ <b> function4 </b> <br> trying -> 2 <br> return -> 4 <br> Total: 6]
28,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  __u8 check_helper(__u32 value, __u16 auxiliar) { if(value > auxiliar) return 1; else return 0; }  __u32 helping_hand(__u32 value, __u16 auxiliar) { value = value + auxiliar; __u8 returned = check_helper(value, auxiliar); if(returned) return value - auxiliar; else return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; value = helping_hand(value, 25);  __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start && value) { check_helper(value, value - 1); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 4 <br> data_start -> 4 <br> data_end -> 4 <br> Total: 20 ] --> B A --> C  B[ <b> helping_hand </b> <br> value -> 4 <br> auxiliar -> 2 <br> returned -> 1 <br> return -> 4 <br> Total: 11] --> C  C[ <b> check_helper </b> <br> value -> 4 <br> auxiliar -> 2 <br> return -> 1 <br> Total: 7]
29,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); *value = *value + 1; } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_start -> 4 <br> data_end -> 4 <br> key -> 4 + 4 <br> value -> 8 <br> Total: 32 ]
30,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); *value = *value + 1;  struct value *value2 = bpf_map_lookup_elem(&map_value, &key); value2->testing = *value; value2->testing2 = value2->testing * (*value); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_start -> 4 <br> data_end -> 4 <br> key -> 4 + 4 <br> value -> 8 <br> value2 -> 8 <br> Total: 40 ]
31,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  void updating_map(__u32 key) { __u32* value = bpf_map_lookup_elem(&xdp_map, &key); *value = *value + 1; struct value *value2 = bpf_map_lookup_elem(&map_value, &key); value2->testing = *value; value2->testing2 = value2->testing * (*value); }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; updating_map(key); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_start -> 4 <br> data_end -> 4 <br> key -> 4 <br> Total: 20 ] --> B  B[ <b> updating_map </b> <br> key -> 4 + 4 <br> value -> 8 <br> value2 -> 8 <br> Total: 24]
32,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  void updating_map(__u32 *value, struct value *value2) { *value = *value + 1; value2->testing = *value; value2->testing2 = value2->testing * (*value); }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); struct value *value2 = bpf_map_lookup_elem(&map_value, &key); updating_map(value, value2); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_start -> 4 <br> data_end -> 4 <br> key -> 4 + 4 <br> value -> 8 <br> value2 -> 8 <br> Total: 40 ] --> B  B[ <b> updating_map </b> <br> value -> 8 <br> value2 -> 8 <br> Total: 16]
33,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  __u32 helping_func(__u32 valiable) { if(valiable * 2 > 500) return valiable; else return 0; }  void updating_map(__u32 *value, struct value *value2) { *value = *value + 1; value2->testing = *value; value2->testing2 = value2->testing * (*value); if(*value > 5) { *value = helping_func(*value); } }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); struct value *value2 = bpf_map_lookup_elem(&map_value, &key); updating_map(value, value2); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_start -> 4 <br> data_end -> 4 <br> key -> 4 + 4 <br> value -> 8 <br> value2 -> 8 <br> Total: 40 ] --> B  B[ <b> updating_map </b> <br> value -> 8 <br> value2 -> 8 <br> Total: 16] --> C  C[ <b> helping_func </b> <br> valiable -> 4 <br> return -> 4 <br> Total: 8]
34,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  __u32 helping_func(__u32 valiable) { if(valiable * 2 > 500) return valiable; else return 0; }  __u32 second_func(__u32 number) { return number * 10; }  void updating_map(__u32 *value, struct value *value2) { *value = *value + 1; value2->testing = *value; value2->testing2 = value2->testing * (*value); if(*value > 5) { *value = helping_func(*value); } else { value2->testing = second_func(*value); } }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); struct value *value2 = bpf_map_lookup_elem(&map_value, &key); updating_map(value, value2); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_start -> 4 <br> data_end -> 4 <br> key -> 4 + 4 <br> value -> 8 <br> value2 -> 8 <br> Total: 40 ] --> B  B[ <b> updating_map </b> <br> value -> 8 <br> value2 -> 8 <br> Total: 16] --> C B --> D  C[ <b> helping_func </b> <br> valiable -> 4 <br> return -> 4 <br> Total: 8]  D[ <b> second_func </b> <br> number -> 4 <br> Total: 4]
35,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");  __u32 helping_func(__u32 valiable) { if(valiable * 2 > 500) return valiable; else return 0; }  __u32 second_func(__u32 number) { return number * 10; }  void updating_map(__u32 *value, struct value *value2) { *value = *value + 1; value2->testing = *value; value2->testing2 = value2->testing * (*value); if(*value > 5) { *value = helping_func(*value); } else { value2->testing = second_func(*value); } }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 data_start = ctx->data; __u32 data_end = ctx->data_end; if(data_end > data_start) { __u32 key = 0; __u32* value = bpf_map_lookup_elem(&xdp_map, &key); struct value *value2 = bpf_map_lookup_elem(&map_value, &key); updating_map(value, value2);  helping_func(*value); second_func(value2->testing2); } return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_start -> 4 <br> data_end -> 4 <br> key -> 4 + 4 <br> value -> 8 <br> value2 -> 8 <br> Total: 40 ] --> B A --> C A --> D  B[ <b> updating_map </b> <br> value -> 8 <br> value2 -> 8 <br> Total: 16] --> C B --> D  C[ <b> helping_func </b> <br> valiable -> 4 <br> return -> 4 <br> Total: 8]  D[ <b> second_func </b> <br> number -> 4 <br> Total: 4]
36,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 32); } xdp_map SEC("".maps"");  struct value { __u32 testing; __u32 testing2; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct value); __uint(max_entries, 32); } map_value SEC("".maps"");   __u32 multiply_ten(__u32 number) { return number * 10; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u64 value = 1; __u8 value1 = 2; __u16 value2 = 3; __u8 value3 = 4; __u32 value4 = 5;  __u64 total = value + value1 + value2 + value3 + value4; total = multiply_ten(total);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> value -> 8 <br> value1 -> 1 + 1 <br> value2 -> 2 <br> value3 -> 1 + 3 <br> value4 -> 4 + 4 <br> total -> 8 <br> Total: 40 ] --> B  B[ <b> multiply_ten </b> <br> number -> 4 <br> Total: 4]
37,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h>  struct hdr_cursor { void *pos; };   int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  /* Byte-count bounds check; check if current pointer + size of header * is after data_end. */ if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; /* network-byte-order */ }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  /* Default action XDP_PASS, imply everything we couldn't parse, or that * we don't want to deal with, we just pass up the stack and let the * kernel deal with it. */ __u32 action = XDP_PASS; /* Default action */  /* These keep track of the next header type and iterator pointer */ struct hdr_cursor nh; int nh_type;  /* Start next header cursor position at data start */ nh.pos = data;  /* Packet parsing in steps: Get each header one at a time, aborting if * parsing fails. Each helper function does sanity checking (is the * header type in the packet correct?), and bounds checking. */ nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_end -> 8 <br> data -> 8 <br> eth -> 8 <br> action -> 4 + 4 <br> nh -> 8 <br> nh_type -> 4 <br> return -> 4 <br> Total: 60 ] --> B  B[ <b> parse_ethhdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ethhdr -> 8 <br> eth -> 8 <br> hdrsize -> 4 <br> Total: 44]
38,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }  int parse_ip6hdr(struct hdr_cursor *nh, void *data_end, struct ipv6hdr **ip6hdr) { struct ipv6hdr *ip6h = nh->pos;  if (ip6h + 1 > data_end) return -1;  nh->pos = ip6h + 1; *ip6hdr = ip6h;  return ip6h->nexthdr; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct ipv6hdr *ip6h; struct icmp6hdr *icmp6h;  nh_type = parse_ip6hdr(&nh, data_end, &ip6h); if (nh_type != IPPROTO_ICMPV6) return XDP_DROP;   return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_end -> 8 <br> data -> 8 <br> eth -> 8 <br> nh -> 8 <br> nh_type -> 4 + 4 <br> ip6h -> 8 <br> return -> 8 <br> Total: 64 ] --> B A --> C  B[ <b> parse_ethhdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ethhdr -> 8 <br> eth -> 8 <br> hdrsize -> 4 <br> Total: 44]  C[ <b> parse_ip6hdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ip6hdr -> 8 <br> ip6h -> 8 <br> return -> 8 <br> Total: 40]
39,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };  int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }  int parse_ip6hdr(struct hdr_cursor *nh, void *data_end, struct ipv6hdr **ip6hdr) { struct ipv6hdr *ip6h = nh->pos;  if (ip6h + 1 > data_end) return -1;  nh->pos = ip6h + 1; *ip6hdr = ip6h;  return ip6h->nexthdr; }  int parse_icmp6hdr(struct hdr_cursor *nh, void *data_end, struct icmp6hdr **icmp6hdr) { struct icmp6hdr *icmp6h = nh->pos;  if (icmp6h + 1 > data_end) return -1;  nh->pos   = icmp6h + 1; *icmp6hdr = icmp6h;  return icmp6h->icmp6_type; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct ipv6hdr *ip6h; struct icmp6hdr *icmp6h;  nh_type = parse_ip6hdr(&nh, data_end, &ip6h); if (nh_type != IPPROTO_ICMPV6) return XDP_DROP;  nh_type = parse_icmp6hdr(&nh, data_end, &icmp6h); if (nh_type != ICMPV6_ECHO_REQUEST) return XDP_DROP;  if (bpf_ntohs(icmp6h->icmp6_sequence) == 0) return XDP_DROP;  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_end -> 8 <br> data -> 8 <br> eth -> 8 <br> nh -> 8 <br> nh_type -> 4 + 4 <br> ip6h -> 8 <br> icmp6h -> 8 <br> return -> 8 <br> Total: 72 ] --> B A --> C A --> D  B[ <b> parse_ethhdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ethhdr -> 8 <br> eth -> 8 <br> hdrsize -> 4 <br> Total: 44]  C[ <b> parse_ip6hdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ip6hdr -> 8 <br> ip6h -> 8 <br> return -> 8 <br> Total: 40]  D[ <b> parse_icmp6hdr </b> <br> nh -> 8 <br> data_end -> 8 <br> icmp6hdr -> 8 <br> icmp6h -> 8 <br> return -> 8 <br> Total: 40]
40,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }   int parse_iphdr(struct hdr_cursor *nh, void *data_end, struct iphdr **iphdr) { struct iphdr *iph = nh->pos; int hdrsize;  if (iph + 1 > data_end) return -1;  hdrsize = iph->ihl * 4;  if(hdrsize < sizeof(*iph)) return -1;  if (nh->pos + hdrsize > data_end) return -1;  nh->pos += hdrsize; *iphdr = iph;  return iph->protocol; }   SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct iphdr *iph; struct icmphdr *icmph;  nh_type = parse_iphdr(&nh, data_end, &iph); if (nh_type != 0) return XDP_DROP;   return XDP_DROP; }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_end -> 8 <br> data -> 8 <br> eth -> 8 <br> nh -> 8 <br> nh_type -> 4 + 4 <br> iph -> 8 <br> return -> 8 <br> Total: 64 ] --> B A --> C  B[ <b> parse_ethhdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ethhdr -> 8 <br> eth -> 8 <br> hdrsize -> 4 <br> Total: 44]  C[ <b> parse_iphdr </b> <br> nh -> 8 <br> data_end -> 8 <br> iphdr -> 8 <br> iph -> 8 <br> hdrsize -> 4 <br> return -> 8 <br> Total: 44]
41,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }   int parse_iphdr(struct hdr_cursor *nh, void *data_end, struct iphdr **iphdr) { struct iphdr *iph = nh->pos; int hdrsize;  if (iph + 1 > data_end) return -1;  hdrsize = iph->ihl * 4;  if(hdrsize < sizeof(*iph)) return -1;  if (nh->pos + hdrsize > data_end) return -1;  nh->pos += hdrsize; *iphdr = iph;  return iph->protocol; }  int parse_icmphdr(struct hdr_cursor *nh, void *data_end, struct icmphdr **icmphdr) { struct icmphdr *icmph = nh->pos;  if (icmph + 1 > data_end) return -1;  nh->pos  = icmph + 1; *icmphdr = icmph;  return icmph->type; }   SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct iphdr *iph; struct icmphdr *icmph;  nh_type = parse_iphdr(&nh, data_end, &iph); if (nh_type != 0) return XDP_DROP;  nh_type = parse_icmphdr(&nh, data_end, &icmph); if (nh_type != ICMP_ECHO) return XDP_DROP;  return XDP_DROP; }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_end -> 8 <br> data -> 8 <br> eth -> 8 <br> nh -> 8 <br> nh_type -> 4 + 4 <br> iph -> 8 <br> icmph -> 8 <br> return -> 8 <br> Total: 72 ] --> B A --> C A --> D  B[ <b> parse_ethhdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ethhdr -> 8 <br> eth -> 8 <br> hdrsize -> 4 <br> Total: 44]  C[ <b> parse_iphdr </b> <br> nh -> 8 <br> data_end -> 8 <br> iphdr -> 8 <br> iph -> 8 <br> hdrsize -> 4 <br> return -> 8 <br> Total: 44]  D[ <b> parse_icmphdr </b> <br> nh -> 8 <br> data_end -> 8 <br> icmphdr -> 8 <br> icmph -> 8 <br> return -> 8 <br> Total: 40]
42,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }   int parse_iphdr(struct hdr_cursor *nh, void *data_end, struct iphdr **iphdr) { struct iphdr *iph = nh->pos; int hdrsize;  if (iph + 1 > data_end) return -1;  hdrsize = iph->ihl * 4;  if(hdrsize < sizeof(*iph)) return -1;  if (nh->pos + hdrsize > data_end) return -1;  nh->pos += hdrsize; *iphdr = iph;  return iph->protocol; }  void swap_src_dst_mac(struct ethhdr *eth) { __u8 h_tmp[ETH_ALEN];  __builtin_memcpy(h_tmp, eth->h_source, ETH_ALEN); __builtin_memcpy(eth->h_source, eth->h_dest, ETH_ALEN); __builtin_memcpy(eth->h_dest, h_tmp, ETH_ALEN); }   SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct iphdr *iph;  nh_type = parse_iphdr(&nh, data_end, &iph); if (nh_type != 0) return XDP_DROP;  swap_src_dst_mac(eth);  return XDP_DROP; }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_end -> 8 <br> data -> 8 <br> eth -> 8 <br> nh -> 8 <br> nh_type -> 4 + 4 <br> iph -> 8 <br> return -> 8 <br> Total: 64 ] --> B A --> C A --> D  B[ <b> parse_ethhdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ethhdr -> 8 <br> eth -> 8 <br> hdrsize -> 4 <br> Total: 44]  C[ <b> parse_iphdr </b> <br> nh -> 8 <br> data_end -> 8 <br> iphdr -> 8 <br> iph -> 8 <br> hdrsize -> 4 <br> return -> 8 <br> Total: 44]  D[ <b> swap_src_dst_mac </b> <br> eth -> 8 <br> h_tmp -> 8 <br> Total: 16]
43,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/ipv6.h> #include <linux/icmp.h> #include <linux/icmpv6.h> #include <linux/udp.h> #include <linux/tcp.h>  struct hdr_cursor { void *pos; };   int parse_ethhdr(struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr) { struct ethhdr *eth = nh->pos; int hdrsize = sizeof(*eth);  if (nh->pos + 1 > data_end) return -1;  nh->pos += hdrsize; *ethhdr = eth;  return eth->h_proto; }   int parse_iphdr(struct hdr_cursor *nh, void *data_end, struct iphdr **iphdr) { struct iphdr *iph = nh->pos; int hdrsize;  if (iph + 1 > data_end) return -1;  hdrsize = iph->ihl * 4;  if(hdrsize < sizeof(*iph)) return -1;  if (nh->pos + hdrsize > data_end) return -1;  nh->pos += hdrsize; *iphdr = iph;  return iph->protocol; }  void swap_src_dst_mac(struct ethhdr *eth) { __u8 h_tmp[ETH_ALEN];  __builtin_memcpy(h_tmp, eth->h_source, ETH_ALEN); __builtin_memcpy(eth->h_source, eth->h_dest, ETH_ALEN); __builtin_memcpy(eth->h_dest, h_tmp, ETH_ALEN); }  void swap_src_dst_ipv4(struct iphdr *iphdr) { __be32 tmp = iphdr->saddr;  iphdr->saddr = iphdr->daddr; iphdr->daddr = tmp; }   SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data; struct ethhdr *eth;  struct hdr_cursor nh; int nh_type;  nh.pos = data;  nh_type = parse_ethhdr(&nh, data_end, &eth); if (nh_type != bpf_htons(ETH_P_IPV6)) return XDP_DROP;  struct iphdr *iph;  nh_type = parse_iphdr(&nh, data_end, &iph); if (nh_type != 0) return XDP_DROP;  swap_src_dst_mac(eth);  swap_src_dst_ipv4(iph);  return XDP_DROP; }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> data_end -> 8 <br> data -> 8 <br> eth -> 8 <br> nh -> 8 <br> nh_type -> 4 + 4 <br> iph -> 8 <br> return -> 8 <br> Total: 64 ] --> B A --> C A --> D A --> E  B[ <b> parse_ethhdr </b> <br> nh -> 8 <br> data_end -> 8 <br> ethhdr -> 8 <br> eth -> 8 <br> hdrsize -> 4 <br> Total: 44]  C[ <b> parse_iphdr </b> <br> nh -> 8 <br> data_end -> 8 <br> iphdr -> 8 <br> iph -> 8 <br> hdrsize -> 4 <br> return -> 8 <br> Total: 44]  D[ <b> swap_src_dst_mac </b> <br> eth -> 8 <br> h_tmp -> 8 <br> Total: 16]  E[ <b> swap_src_dst_ipv4 </b> <br> iphdr -> 8 <br> tmp -> 4 <br> Total: 12]
44,"/* SPDX-License-Identifier: GPL-2.0 */  #include <linux/bpf.h>  #include <bpf/bpf_helpers.h>  struct { __uint(type, BPF_MAP_TYPE_XSKMAP); __type(key, __u32); __type(value, __u32); __uint(max_entries, 64); } xsks_map SEC("".maps"");  struct { __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY); __type(key, __u32); __type(value, __u32); __uint(max_entries, 64); } xdp_stats_map SEC("".maps"");  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { int index = ctx->rx_queue_index; __u32 *pkt_count;  pkt_count = bpf_map_lookup_elem(&xdp_stats_map, &index); if (pkt_count) {  /* We pass every other packet */ if ((*pkt_count)++ & 1) return XDP_PASS; }  /* A set entry here means that the correspnding queue_id * has an active AF_XDP socket bound to it. */ if (bpf_map_lookup_elem(&xsks_map, &index)) return bpf_redirect_map(&xsks_map, index, 0);  return XDP_PASS; }  char _license[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> index -> 4 + 4 <br> pkt_count -> 8 <br> return -> 8 <br> Total: 32 ]
45,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h>  #define MAX_NUMBER_CORES 8  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u64); __uint(max_entries, MAX_NUMBER_CORES); } common_array SEC("".maps"");  struct info { __u64 latency; __u64 counter; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct info); __uint(max_entries, MAX_NUMBER_CORES); } info_array SEC("".maps"");  int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0;  struct info new_value; new_value.latency = value->latency + (finish_time - arrival_time); new_value.counter = value->counter + 1; bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);  return 1; }   int lookup_map (int key, void * map_pointer) { __u64 * value = bpf_map_lookup_elem(map_pointer, &key);  if(!value) return 0;  *value += 1;  return 1; }   SEC(""xdp"") int  xdp_prog(struct xdp_md *ctx) { __u32 cpu = bpf_get_smp_processor_id();  __u64 arrival_time = bpf_ktime_get_ns();  lookup_map(cpu, &common_array);  __u64 finish_time = bpf_ktime_get_ns(); if(!update_info(arrival_time, finish_time, cpu)) { bpf_printk(""Error while looking up timer map""); }  return XDP_DROP; }  char _license[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> cpu -> 4 + 4 <br> arrival_time -> 8 <br> finish_time -> 8 <br> Error while looking up timer map -> 40 <br> Total: 72 ] --> B A --> C  B[ <b> lookup_map </b> <br> key -> 4 <br> map_pointer -> 8 <br> value -> 8 <br> return -> 4 <br> Total: 24]  C[ <b> update_info </b> <br> arrival_time -> 8 <br> finish_time -> 8 <br> key_cpu -> 4 + 4 <br> value -> 8 <br> new_value -> 16 <br> return -> 8 <br> Total: 56]
46,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h>  #define MAX_NUMBER_CORES 8  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, __u64); __uint(max_entries, MAX_NUMBER_CORES); } common_array SEC("".maps"");  struct info { __u64 latency; __u64 counter; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct info); __uint(max_entries, MAX_NUMBER_CORES); } info_array SEC("".maps"");  int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0;  struct info new_value; new_value.latency = value->latency + (finish_time - arrival_time); new_value.counter = value->counter + 1; bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);  return 1; }   int lookup_map (int key, void * map_pointer) { __u64 * value = bpf_map_lookup_elem(map_pointer, &key);  if(!value) return 0;  *value += 1;  return 1; }  __u32 get_and_check_cpu_id() { __u32 cpu = bpf_get_smp_processor_id(); if(cpu >= 10) cpu -= 10; return cpu; }   SEC(""xdp"") int  xdp_prog(struct xdp_md *ctx) { __u32 cpu = get_and_check_cpu_id();  __u64 arrival_time = bpf_ktime_get_ns();  lookup_map(cpu, &common_array);  __u64 finish_time = bpf_ktime_get_ns(); if(!update_info(arrival_time, finish_time, cpu)) { return XDP_DROP; }  return XDP_DROP; }  char _license[] SEC(""license"") = ""GPL"";",graph TD A[ <b> xdp_prog </b> <br> ctx -> 8 <br> cpu -> 4 + 4 <br> arrival_time -> 8 <br> finish_time -> 8 <br> return -> 8 <br> Total: 40 ] --> B A --> C A --> D  B[ <b> get_and_check_cpu_id </b> <br> cpu -> 4 <br> Total: 4]  C[ <b> lookup_map </b> <br> key -> 4 <br> map_pointer -> 8 <br> value -> 8 <br> return -> 4 <br> Total: 24]  D[ <b> update_info </b> <br> arrival_time -> 8 <br> finish_time -> 8 <br> key_cpu -> 4 + 4 <br> value -> 8 <br> new_value -> 16 <br> return -> 8 <br> Total: 56]
47,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h>  #define MAX_NUMBER_CORES 8  struct inner_map_queue { __uint(type, BPF_MAP_TYPE_QUEUE); __type(value, __u64); __uint(max_entries, 32); } inner_map_queue0 SEC("".maps""), inner_map_queue1 SEC("".maps""), inner_map_queue2 SEC("".maps""), inner_map_queue3 SEC("".maps""), inner_map_queue4 SEC("".maps""), inner_map_queue5 SEC("".maps""), inner_map_queue6 SEC("".maps""), inner_map_queue7 SEC("".maps"");  struct { __uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS); __uint(max_entries, MAX_NUMBER_CORES); __type(key, __u32); __array(values, struct inner_map_queue); } outer_map_queue SEC("".maps"") = { .values = {&inner_map_queue0, &inner_map_queue1, &inner_map_queue2, &inner_map_queue3, &inner_map_queue4, &inner_map_queue5, &inner_map_queue6, &inner_map_queue7} };  struct info { __u64 latency; __u64 counter; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct info); __uint(max_entries, MAX_NUMBER_CORES); } info_array SEC("".maps"");  int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0;  struct info new_value; new_value.latency = value->latency + (finish_time - arrival_time); new_value.counter = value->counter + 1; bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);  return 1; }   __u64 lookup_map_of_maps_queue (int key, __u64 counter/*, int iteration*/) {  struct inner_map_queue *map = bpf_map_lookup_elem(&outer_map_queue, &key);  if(!map) { return 0; }  __u64 value;  if(bpf_map_peek_elem(map, &value) < 0) { return 0; }  if(bpf_map_push_elem(map, &counter, BPF_EXIST) < 0) { return 0; }  return counter; }  __u64 get_counter (int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0; return value->counter; }  SEC(""xdp"") int  map_of_maps_queue(struct xdp_md *ctx) { __u32 cpu = bpf_get_smp_processor_id();  __u64 counter = get_counter(cpu);  __u64 arrival_time = bpf_ktime_get_ns();  lookup_map_of_maps_queue(cpu, counter);  __u64 finish_time = bpf_ktime_get_ns(); if(!update_info(arrival_time, finish_time, cpu)) { return XDP_DROP; }  return XDP_DROP; }  char _license[] SEC(""license"") = ""GPL"";",graph TD A[ <b> map_of_maps_queue </b> <br> ctx -> 8 <br> cpu -> 4 + 4 <br> counter -> 8 <br> arrival_time -> 8 <br> finish_time -> 8 <br> return -> 8 <br> Total: 48 ] --> B A --> C A --> D  B[ <b> lookup_map_of_maps_queue </b> <br> key -> 4 + 4 <br> counter -> 8 <br> map -> 8 <br> value -> 8 <br> return -> 8 <br> Total: 40]  C[ <b> update_info </b> <br> arrival_time -> 8 <br> finish_time -> 8 <br> key_cpu -> 4 + 4 <br> value -> 8 <br> new_value -> 16 <br> return -> 8 <br> Total: 56]  D[ <b> get_counter </b> <br> key_cpu -> 4 + 4 <br> value -> 8 <br> return -> 8 <br> Total: 24]
48,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h>  #define MAX_NUMBER_CORES 8  struct map_locked_value { __u64 value; struct bpf_spin_lock lock; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct map_locked_value); __uint(max_entries, MAX_NUMBER_CORES); } lock_array SEC("".maps"");  struct info { __u64 latency; __u64 counter; };  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __type(key, __u32); __type(value, struct info); __uint(max_entries, MAX_NUMBER_CORES); } info_array SEC("".maps"");  int update_info (__u64 arrival_time, __u64 finish_time, int key_cpu) { struct info *value = bpf_map_lookup_elem(&info_array, &key_cpu); if(!value) return 0;  struct info new_value; new_value.latency = value->latency + (finish_time - arrival_time); new_value.counter = value->counter + 1; bpf_map_update_elem(&info_array, &key_cpu, &new_value, BPF_ANY);  return 1; }   int lookup_lock_map (int key) {  struct map_locked_value *lock_value = bpf_map_lookup_elem(&lock_array, &key);  if(!lock_value) { return 0; }  bpf_spin_lock(&lock_value->lock);  lock_value->value += 1; bpf_spin_unlock(&lock_value->lock);  return 1; }  SEC(""xdp"") int  lock_map(struct xdp_md *ctx) { int cpu = bpf_get_smp_processor_id();  __u64 arrival_time = bpf_ktime_get_ns();  lookup_lock_map(0);  __u64 finish_time = bpf_ktime_get_ns(); if(!update_info(arrival_time, finish_time, cpu)) { return XDP_DROP; }  return XDP_DROP; }  char _license[] SEC(""license"") = ""GPL"";",graph TD A[ <b> lock_map </b> <br> ctx -> 8 <br> cpu -> 4 + 4 <br> arrival_time -> 8 <br> finish_time -> 8 <br> return -> 8 <br> Total: 40 ] --> B A --> C  B[ <b> lookup_lock_map </b> <br> key -> 4 <br> lock_value -> 8 <br> return -> 4 <br> Total: 16]  C[ <b> update_info </b> <br> arrival_time -> 8 <br> finish_time -> 8 <br> key_cpu -> 4 + 4 <br> value -> 8 <br> new_value -> 16 <br> return -> 8 <br> Total: 56]
49,"/* SPDX-License-Identifier: GPL-2.0 */ #include <linux/bpf.h> #include <linux/in.h> #include <bpf/bpf_helpers.h> #include <linux/if_ether.h> #include <linux/ip.h> #include <linux/tcp.h> #include <bpf/bpf_helpers.h> #include <bpf/bpf_endian.h> #include <time.h>  struct { __uint(type, BPF_MAP_TYPE_ARRAY); __uint(max_entries, 100); __uint(key_size, sizeof(__u32)); __uint(value_size, sizeof(__u32)); } array_map SEC("".maps"");   struct test_struct { __u64 test0; __u8 test1; __u8 test2; __u8 test3; __u8 test4; __u8 test5; __u8 test6; };  int test_function(__u32 var1) { struct test_struct var0 = {0,0,0,0,0,0,0}; var0.test0 = var1; var0.test1 = var0.test0 * var1; var0.test2 = var0.test1 * var1; var0.test3 = var0.test2 * var1; var0.test4 = var0.test3 * var1; return var0.test4; }  int test_function3(var2, var3) { return var2 + var3; }  void test_function2() { __u8 var2 = 152; __u8 var3 = 143; __u16 var4 = 1; var2 = var3 + 123 + var2 + var4; const int key = 0; __u32 * teste = bpf_map_lookup_elem(&array_map, &key); const int key1 = 1; __u32 * teste1 = bpf_map_lookup_elem(&array_map, &key1); const int key2 = 2; __u32 * teste2 = bpf_map_lookup_elem(&array_map, &key2); const int key3 = 3; __u32 * teste3 = bpf_map_lookup_elem(&array_map, &key3); const int key4 = 4; __u32 * teste4 = bpf_map_lookup_elem(&array_map, &key4); const int key5 = 5; __u32 * teste5 = bpf_map_lookup_elem(&array_map, &key5); const int key6 = 6; __u32 * teste6 = bpf_map_lookup_elem(&array_map, &key6); if(!teste || !teste1 || !teste2 || !teste3 || !teste4 || !teste5 || !teste6) return;  var4 = test_function3(var2, var3);  int value = *teste; value = value + 53; return; }  SEC(""xdp"") int testing_stack(struct xdp_md *ctx) { __u64 var1 = 123;  var1 = test_function(var1);  test_function2();  return 0; }  char _license[] SEC(""license"") = ""GPL"";",graph TD A[ <b> testing_stack </b> <br> ctx -> 8 <br> var1 -> 8 <br> Total: 16 ] --> B A --> C  B[ <b> test_function </b> <br> var1 -> 4 + 4 <br> var0 -> 16 <br> Total: 24]  C[ <b> test_function2 </b> <br> var2 -> 1 <br> var3 -> 1 <br> var4 -> 2 <br> key -> 4 <br> teste -> 8 <br> key1 -> 4 + 4 <br> teste1 -> 8 <br> key2 -> 4 + 4 <br> teste2 -> 8 <br> key3 -> 4 + 4 <br> teste3 -> 8 <br> key4 -> 4 + 4 <br> teste4 -> 8 <br> key5 -> 4 + 4 <br> teste5 -> 8 <br> key6 -> 4 + 4 <br> teste6 -> 8 <br> value -> 4 <br> Total: 116] --> D  D[ <b> test_function3 </b> <br> var2 -> 4 <br> var3 -> 4 <br> Total: 8]
50,"// SPDX-License-Identifier: GPL-2.0 #include <linux/bpf.h> #include <bpf/bpf_helpers.h>  struct testing { __u32 amem; __u64 example; };  struct str_testando { __u8 hello; __u64 trying_out; };  __u32 function1(__u32 value);  __u32 function7(__u32 value) { value = value + 1; function1(value); return value; }  __u32 function6(__u32 value) { value = value + 1; function7(value); return value; }  __u32 function5(__u32 value) { value = value + 1; function6(value); return value; }  __u32 function4(__u32 value) { value = value + 1; function5(value); return value; }  __u32 function3(__u32 value) { value = value + 1; return value; }  __u32 function2(__u32 value) { value = value + 1; __u16 roedor = 5; value = roedor + 1; function3(value); return value; }  __u32 function1(__u32 value) { value = value + 1; function2(value); return value; }  SEC(""xdp"") int xdp_prog(struct xdp_md *ctx) { __u32 value = 1; function1(value); function4(value);  return XDP_DROP; // Drop all packets }  char LICENSE[] SEC(""license"") = ""GPL"";",graph TD A[ <b> testing_stack </b> <br> ctx -> 8 <br> value -> 4 <br> Total: 12 ] --> B A --> E  B[ <b> function1 </b> <br> value -> 4 <br> Total: 4] --> C  C[ <b> function2 </b> <br> value -> 4 <br> roedor -> 2 <br> Total: 6] --> D  D[ <b> function3 </b> <br> value -> 4 <br> Total: 4]  E[ <b> function4 </b> <br> value -> 4 <br> Total: 4] --> F  F[ <b> function5 </b> <br> value -> 4 <br> Total: 4] --> G  G[ <b> function6 </b> <br> value -> 4 <br> Total: 4] --> H  H[ <b> function7 </b> <br> value -> 4 <br> Total: 4] --> B
